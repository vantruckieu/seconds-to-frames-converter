<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title id="title">Timing & Render Tool</title>

<style>
@import url('https://fonts.googleapis.com/css2?family=Be+Vietnam+Pro:wght@400;500;600;700&display=swap');

body {
    color-scheme: dark; 
    background: radial-gradient(circle at 20% 20%, #0f1c2e, #050b18 70%);
    font-family: 'Google Sans', 'Be Vietnam Pro', 'Segoe UI', sans-serif;
    color: #e6f3ff;
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 0;
    padding: 40px 20px 80px 20px;
    min-height: 100vh;
    box-sizing: border-box;
}

h1 { margin: 0 0 10px 0; font-size: 28px; text-align: center; color: #00ccff; text-shadow: 0 0 20px rgba(0,200,255,0.6); }
.intro { text-align: center; max-width: 600px; margin-bottom: 30px; opacity: 0.8; line-height: 1.5; font-size: 15px; }

.container {
    background: linear-gradient(145deg, #0e1624, #111c2f);
    padding: 35px; border-radius: 20px; width: 100%; max-width: 600px; 
    box-shadow: 0 0 40px rgba(0,140,255,0.25), inset 0 0 60px rgba(0,80,160,0.15);
    border: 1px solid rgba(0,180,255,0.2); box-sizing: border-box;
}

.tabs { display: flex; gap: 8px; margin-bottom: 25px; flex-wrap: wrap; }
.tabs button {
    flex: 1; min-width: 120px; padding: 12px 5px; min-height: 44px;
    background: #0c1626; border: 1px solid #1b3555; border-radius: 10px;
    color: #7fbfff; cursor: pointer; transition: 0.3s; font-weight: 500; font-family: inherit; font-size: 14px;
}
.tabs button:hover { background: #11233d; box-shadow: 0 0 12px rgba(0,170,255,0.4); }
.tabs button.active { background: linear-gradient(90deg,#0066ff,#00ccff); color: white; border-color: #00ccff; box-shadow: 0 0 20px rgba(0,200,255,0.6); }

.tab-desc { font-size: 13px; color: #9ed8ff; background: rgba(0, 150, 255, 0.08); border-left: 3px solid #00ccff; padding: 12px 15px; margin-bottom: 22px; border-radius: 0 8px 8px 0; line-height: 1.5; }
.row { margin-bottom: 20px; transition: all 0.3s ease; }
label { display: flex; align-items: center; margin-bottom: 8px; font-size: 14px; opacity: 0.85; color: #9ed8ff; }

input[type="number"] {
    width: 100%; padding: 14px; font-size: 16px; min-height: 44px; font-family: inherit;
    background: #0a1422; border: 1px solid #1e3a5f; border-radius: 10px; color: #e6f3ff; transition: 0.3s; box-sizing: border-box;
}
input[type="number"]:focus { outline: none; border-color: #00ccff; box-shadow: 0 0 12px rgba(0,200,255,0.5); }

/* CUSTOM DROPDOWN */
.custom-select-wrapper { position: relative; width: 100%; }
.custom-select-wrapper:has(select.hidden) { display: none !important; }
.input-group .custom-select-wrapper { flex: 1; }
.custom-select-trigger {
    width: 100%; padding: 14px; font-size: 15px; font-family: inherit; min-height: 44px;
    background: #0a1422; border: 1px solid #1e3a5f; border-radius: 10px; color: #e6f3ff; cursor: pointer; display: flex; justify-content: space-between; align-items: center; transition: 0.3s; box-sizing: border-box; user-select: none;
}
.custom-select-trigger:hover, .custom-select-trigger.active { border-color: #00ccff; box-shadow: 0 0 12px rgba(0,200,255,0.5); }
.custom-select-trigger .arrow {
    width: 16px; height: 16px; background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%239ed8ff' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e"); background-size: contain; background-repeat: no-repeat; background-position: center; transition: transform 0.3s;
}
.custom-select-trigger.active .arrow { transform: rotate(180deg); }
.custom-select-options {
    position: absolute; top: calc(100% + 5px); left: 0; right: 0; background: #0a1422;
    border: 1px solid #1e3a5f; border-radius: 10px; box-shadow: 0 5px 20px rgba(0,0,0,0.6); z-index: 99; opacity: 0; visibility: hidden; transform: translateY(-10px); transition: all 0.2s ease-out; overflow-y: auto; max-height: 250px;
}
.custom-select-options.show { opacity: 1; visibility: visible; transform: translateY(0); }
.custom-select-option { padding: 14px; font-size: 14px; cursor: pointer; transition: 0.2s; color: #e6f3ff; border-bottom: 1px solid rgba(30, 58, 95, 0.4); }
.custom-select-option:last-child { border-bottom: none; }
.custom-select-option:hover, .custom-select-option.selected { background: #11233d; color: #00ccff; }

.input-group { display: flex; gap: 10px; flex-wrap: wrap; }
.input-group input[type="number"], .input-group .custom-select-wrapper { flex: 1; min-width: 140px; }
.fps-presets { display: flex; gap: 8px; margin-top: 10px; }
.fps-presets button { flex: 1; padding: 10px 6px; background: #0e1c2f; border: 1px solid #1f4068; border-radius: 8px; color: #66ccff; cursor: pointer; font-size: 14px; transition: 0.2s; min-height: 40px; }
.fps-presets button:hover { background: #133a66; box-shadow: 0 0 8px rgba(0,200,255,0.6); }

.result { margin-top: 25px; font-size: 24px; font-weight: bold; color: #00ccff; text-align: center; text-shadow: 0 0 15px rgba(0,200,255,0.6); }
.sub-result { display: block; font-size: 14px; font-weight: normal; color: #9ed8ff; margin-top: 8px; opacity: 0.9; line-height: 1.5; }
.box-result { font-size: 14px; color: #cceeff; background: rgba(0, 102, 255, 0.1); border: 1px dashed #0066ff; padding: 15px; border-radius: 10px; margin-top: 15px; text-align: left; line-height: 1.6;}

.tooltip {
    display: inline-flex; align-items: center; justify-content: center; width: 18px; height: 18px; background: rgba(0, 204, 255, 0.1); border: 1px solid #00ccff; border-radius: 50%; color: #00ccff; font-size: 12px; font-weight: bold; cursor: help; position: relative; margin-left: 8px; transition: 0.3s;
}
.tooltip:hover { background: #00ccff; color: #0a1422; box-shadow: 0 0 10px rgba(0, 204, 255, 0.6); }
.tooltip:hover::after {
    content: attr(data-tip); position: absolute; bottom: 150%; left: 50%; transform: translateX(-50%); background: #02111f; padding: 12px 14px; font-size: 13px; font-weight: normal; border-radius: 8px; width: 250px; color: #cceeff; box-shadow: 0 4px 15px rgba(0,170,255,0.6); border: 1px solid rgba(0, 204, 255, 0.4); z-index: 9999; text-align: left; white-space: pre-wrap; line-height: 1.5; word-wrap: break-word;
}
.warning { margin-top: 15px; font-size: 14px; color: #ffcc66; background: rgba(255, 204, 102, 0.1); padding: 15px; border-radius: 10px; border: 1px solid rgba(255, 204, 102, 0.3); line-height: 1.5;}
.hidden { display: none !important; }

/* Graph Styling */
.graph-title-block { display: flex; justify-content: space-between; align-items: center; margin-top: 25px; margin-bottom: 8px; }
.graph-title { font-size: 13px; font-weight: 600; color: #9ed8ff; display: flex; align-items: center; justify-content: center; gap: 6px; }

.static-graph-wrapper { background: rgba(10, 20, 34, 0.4); border-radius: 12px; border: 1px dashed #1e3a5f; width: 100%; margin-top: 5px; box-sizing: border-box; display: flex; justify-content: center; padding: 15px 0; overflow: hidden; }
.graph-wrapper { margin-top: 5px; background: rgba(10, 20, 34, 0.6); border-radius: 12px; border: 1px solid #1e3a5f; width: 100%; overflow-x: auto; box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.5); padding: 15px 0 0 0; -webkit-overflow-scrolling: touch; }
.graph-wrapper::-webkit-scrollbar { height: 8px; }
.graph-wrapper::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); border-radius: 10px; }
.graph-wrapper::-webkit-scrollbar-thumb { background: #1e3a5f; border-radius: 10px; }
.graph-wrapper::-webkit-scrollbar-thumb:hover { background: #00ccff; }
.graph-canvas { display: block; background: transparent; border: none; box-shadow: none; margin: 0 auto; }

/* Custom Curve Editor */
.custom-editor { margin-top: 15px; padding: 15px 20px; background: rgba(10, 20, 34, 0.8); border: 1px solid #00ccff; border-radius: 12px; position: relative; }
.custom-editor.disabled { opacity: 0.4; pointer-events: none; border-color: #1e3a5f; }
.editor-controls { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; flex-wrap: wrap; gap: 10px; }
.editor-controls span { font-size: 13px; color: #00ccff; font-weight: 600;}
.editor-controls-left { display: flex; align-items: center; gap: 12px; }
.editor-btn-group { display: flex; gap: 8px; align-items: center; }
.editor-btn { background: #0c1626; border: 1px solid #1b3555; color: #9ed8ff; border-radius: 6px; padding: 6px 12px; cursor: pointer; font-size: 12px; transition: 0.2s;}
.editor-btn:hover { background: #11233d; color: #00ccff; border-color:#00ccff; }
.btn-reset { color: #ffcc66; border-color: rgba(255, 204, 102, 0.4); }
.btn-reset:hover { background: rgba(255, 204, 102, 0.1); border-color: #ffcc66; color: #ffcc66; }
.checkbox-lbl { font-size: 12px; color: #9ed8ff; display: flex; align-items: center; gap: 5px; cursor: pointer; margin-right: 4px;}
.checkbox-lbl input { width: auto; min-height: auto; margin: 0; }
.editor-canvas-wrap { width: 100%; height: 160px; background: #050b18; border-radius: 8px; border: 1px dashed #1e3a5f; cursor: crosshair; touch-action: none; position: relative;}

/* Outside Legend */
.graph-legend-box { display: flex; justify-content: center; gap: 20px; padding: 12px 0 0 0; font-size: 13px; color: #9ed8ff; }
.graph-legend-box span { display: flex; align-items: center; gap: 6px; }

footer { margin-top: 40px; font-size: 14px; color: #66ccff; opacity: 0.8; display: flex; align-items: center; justify-content: center; gap: 10px; }
footer .custom-select-wrapper { width: auto; min-width: 110px; }
footer .custom-select-trigger { padding: 8px 12px; font-size: 14px; border-radius: 6px; min-height: unset; }

.note-text { font-size: 13px; color: #66ccff; margin-top: 6px; display: block; opacity: 0.8; }

@media (max-width: 600px) {
    body { padding: 20px 10px 50px 10px; }
    .container { padding: 25px 20px; border-radius: 15px; }
    h1 { font-size: 24px; }
}
</style>
</head>

<body>

<h1 id="mainTitle">Timing & Render Tool</h1>
<div class="intro" id="introText">C√¥ng c·ª• ƒëa nƒÉng h·ªó tr·ª£ Animation Timing, T√≠nh to√°n Frame v√† Render.</div>

<div class="container">
    <div class="tabs">
        <button id="tabConvert" class="active" onclick="switchTab('convert')">Time / Frame</button>
        <button id="tabAnime" onclick="switchTab('anime')">Anime, Toon Frame</button>
        <button id="tabPose" onclick="switchTab('pose')">D·ª± t√≠nh Pose</button>
        <button id="tabRender" onclick="switchTab('render')">Render Time</button>
    </div>

    <div id="convertMode">
        <div class="tab-desc" id="descConvert">Chuy·ªÉn ƒë·ªïi qua l·∫°i gi·ªØa th·ªùi l∆∞·ª£ng (Gi√¢y/Ph√∫t/Gi·ªù) v√† S·ªë khung h√¨nh (Frames) theo t·ªëc ƒë·ªô chu·∫©n.</div>
        <div class="row">
            <label><span id="lblMode">Lo·∫°i t√≠nh</span><span class="tooltip" id="tipMode" data-tip="?">?</span></label>
            <select id="mode" onchange="updateConvert()"><option id="optF2T" value="f2t">Frame ‚Üí Time</option><option id="optT2F" value="t2f">Time ‚Üí Frame</option></select>
        </div>
        <div class="row">
            <label><span id="lblFPS_conv">FPS</span><span class="tooltip" id="tipFPS_conv" data-tip="?">?</span></label>
            <input type="number" id="fps" step="0.001" value="24" min="1" oninput="updateConvert()">
            <div class="fps-presets">
                <button onclick="setField('fps', 12); updateConvert()">12</button>
                <button onclick="setField('fps', 24); updateConvert()">24</button>
                <button onclick="setField('fps', 30); updateConvert()">30</button>
                <button onclick="setField('fps', 60); updateConvert()">60</button>
            </div>
        </div>
        <div class="row">
            <label><span id="lblInput">S·ªë khung h√¨nh/th·ªùi gian</span><span class="tooltip" id="tipInput" data-tip="?">?</span></label>
            <div class="input-group">
                <input type="number" id="inputValue" min="0" oninput="updateConvert()">
                <select id="timeUnit" class="hidden" onchange="updateConvert()"><option id="optSec" value="1">Gi√¢y</option><option id="optMin" value="60">Ph√∫t</option><option id="optHour" value="3600">Gi·ªù</option></select>
            </div>
        </div>
        <div class="result" id="convertOutput">‚Äî</div>
    </div>

    <div id="animeMode" class="hidden">
        <div class="tab-desc" id="descAnime">Ph√¢n b·ªï kho·∫£ng c√°ch c√°c Keyframe theo quy t·∫Øc Animation (On 1s, 2s, 3s) v√† n·ªôi suy nh·ªãp ƒë·ªô c·∫£nh.</div>
        
        <div class="row">
            <label><span id="lblFocus">T√¢m ƒëi·ªÉm & Tr·∫°ng th√°i</span><span class="tooltip" id="tipFocus" data-tip="?">?</span></label>
            <div class="input-group">
                <select id="focusTarget" onchange="updateAnime()"><option id="optFocScene" value="scene">C·∫£nh</option><option id="optFocChar" value="char">Nh√¢n v·∫≠t/V·∫≠t th·ªÉ</option></select>
                <select id="focusState" onchange="toggleAnimePoseInput(); updateAnime()"><option id="optStateStatic" value="static">Tƒ©nh</option><option id="optStateDynamic" value="dynamic" selected>ƒê·ªông</option></select>
            </div>
        </div>

        <div class="row">
            <label><span id="lblAnimStyle">Ki·ªÉu di·ªÖn ho·∫°t</span><span class="tooltip" id="tipAnimStyle" data-tip="?">?</span></label>
            <select id="animStyle" onchange="updateAnime()"><option id="optOn1s" value="1">On 1s (M∆∞·ª£t / H√†nh ƒë·ªông)</option><option id="optOn2s" value="2" selected>On 2s (Chu·∫©n Anime)</option><option id="optOn3s" value="3">On 3s (Tƒ©nh / Ch·∫≠m)</option></select>
        </div>
        
        <div class="row">
            <label><span id="lblFPS_anime">FPS g·ªëc</span><span class="tooltip" id="tipFPS_anime" data-tip="?">?</span></label>
            <input type="number" id="fpsAnime" value="24" min="1" oninput="updateAnime()">
            <div class="fps-presets">
                <button onclick="setField('fpsAnime', 12); updateAnime()">12</button>
                <button onclick="setField('fpsAnime', 24); updateAnime()">24</button>
                <button onclick="setField('fpsAnime', 30); updateAnime()">30</button>
                <button onclick="setField('fpsAnime', 60); updateAnime()">60</button>
            </div>
        </div>

        <div class="row" id="rowCorePacingA">
            <label><span id="lblCorePacingAnime">Nh·ªãp t√¢m ƒëi·ªÉm</span><span class="tooltip" id="tipCorePacingAnime" data-tip="?">?</span></label>
            <select id="corePacingAnime" onchange="updateAnime()">
                <option id="optCpSuperSlowA" value="superslow">Super Slow</option><option id="optCpSlowmoA" value="slowmo">Slow Motion</option><option id="optCpSlowA" value="slow">Ch·∫≠m</option><option id="optCpNormalA" value="normal" selected>B√¨nh th∆∞·ªùng</option><option id="optCpFastA" value="fast">Nhanh</option><option id="optCpSuperFastA" value="superfast">C·ª±c nhanh</option><option id="optCpTimeSplashA" value="timesplash">Time Splash</option>
            </select>
        </div>

        <div class="row" id="rowCurveTypeA">
            <label><span id="lblCurveTypeAnime">Lo·∫°i ƒë·ªì th·ªã (Ph√¢n b·ªï)</span><span class="tooltip" id="tipCurveTypeAnime" data-tip="?">?</span></label>
            <select id="curveTypeAnime" onchange="toggleAnimeCustom(); updateAnime()">
                <option id="optCvNoneA" value="linear">Kh√¥ng (ƒê·ªÅu)</option><option id="optCvEaseOutA" value="ease_out">ƒê·ªì th·ªã xu·ªëng (Ch·∫≠m d·∫ßn)</option><option id="optCvEaseInA" value="ease_in">ƒê·ªì th·ªã l√™n (Nhanh d·∫ßn)</option><option id="optCvClimaxA" value="climax">ƒêi·ªÉm cao tr√†o (Nhanh gi·ªØa)</option><option id="optCvLowPointA" value="low_point">ƒêi·ªÉm tr·∫ßm (Ch·∫≠m gi·ªØa)</option><option id="optCvWaveA" value="wave">S√≥ng (Nhanh ch·∫≠m xen k·∫Ω)</option><option id="optCvCustomA" value="custom">T√πy ch·ªânh (Custom)</option>
            </select>
            
            <div id="customEditorWrap_anime" class="custom-editor hidden">
                <div class="editor-controls">
                    <div class="editor-controls-left">
                        <span id="lblEditorA">B·ªô d·ª±ng ƒê·ªì th·ªã</span>
                        <label class="checkbox-lbl"><input type="checkbox" id="smoothCurve_anime" checked> <span id="lblSmoothA">ƒê∆∞·ªùng m∆∞·ª£t</span></label>
                        <label class="checkbox-lbl"><input type="checkbox" id="lockEnd_anime" checked> <span id="lblLockA">Kh√≥a m√∫t</span></label>
                    </div>
                    <div class="editor-btn-group">
                        <button class="editor-btn btn-reset" onclick="resetCustomPoints('anime')" id="btnResetA">Kh√¥i ph·ª•c</button>
                        <button class="editor-btn" onclick="modifyCustomPoints('anime', 1)">+ ƒêi·ªÉm</button>
                        <button class="editor-btn" onclick="modifyCustomPoints('anime', -1)">- ƒêi·ªÉm</button>
                    </div>
                </div>
                <div class="editor-canvas-wrap"><canvas id="customCanvas_anime"></canvas></div>
            </div>
            <div id="warnCustomAnime" class="warning hidden" style="color:#ff6b6b; border-color:#ff6b6b;"></div>
        </div>
        
        <div class="row" id="poseRow">
            <label><span id="lblPose">S·ªë Pose (Keyframes ch√≠nh)</span><span class="tooltip" id="tipPose" data-tip="?">?</span></label>
            <input type="number" id="poseCount" value="5" min="1" oninput="updateAnime()">
        </div>

        <div class="row" id="rowLogicA">
            <label><span id="lblCalcLogic">Logic t√≠nh to√°n</span><span class="tooltip" id="tipCalcLogic" data-tip="?">?</span></label>
            <select id="calcLogic" onchange="toggleAnimeCustom(); updateAnime()"><option id="optLogicStrict" value="strict">To√°n h·ªçc nghi√™m ng·∫∑t</option><option id="optLogicRandom" value="random">X√°c su·∫•t ng·∫´u nhi√™n</option></select>
        </div>

        <div class="row">
            <label><span id="lblFrameRange">Frame B·∫Øt ƒë·∫ßu - K·∫øt th√∫c</span><span class="tooltip" id="tipFrameRange" data-tip="?">?</span></label>
            <div class="input-group">
                <input type="number" id="startFrame" data-i18n-ph="phStartFrame" placeholder="B·∫Øt ƒë·∫ßu (vd: 1)" oninput="updateAnime(); toggleAnimeCustom()">
                <input type="number" id="endFrame" data-i18n-ph="phEndFrame" placeholder="K·∫øt th√∫c (vd: 100)" oninput="updateAnime(); toggleAnimeCustom()">
            </div>
        </div>
        
        <div class="result" id="animeOutput">‚Äî</div>
        <div class="warning" id="warnMathModelAnime">‚ö† L∆∞u √Ω: M√¥ h√¨nh ƒë·ªì th·ªã v√† to√°n h·ªçc ch·ªâ mang t√≠nh ch·∫•t g·ª£i √Ω tham kh·∫£o.</div>
    </div>

    <div id="poseMode" class="hidden">
        <div class="tab-desc" id="descPose">T·ª± ƒë·ªông ∆∞·ªõc t√≠nh s·ªë l∆∞·ª£ng Pose ch√≠nh v√† Pose ph·ª• tr·ª£ (In-betweens) ph·ª• thu·ªôc v√†o h√†nh ƒë·ªông c·ª• th·ªÉ v√† th·ªùi l∆∞·ª£ng.</div>
        <div class="row">
            <label><span id="lblPoseCalcMode">C√°ch t√≠nh to√°n</span><span class="tooltip" id="tipPoseCalcMode" data-tip="?">?</span></label>
            <select id="poseCalcMode" onchange="togglePoseSettings(); togglePoseCustom(); updatePoseEst()"><option id="optPcalcRandom" value="random">X√°c su·∫•t ng·∫´u nhi√™n</option><option id="optPcalcSeconds" value="seconds" selected>Theo s·ªë gi√¢y c·∫£nh</option></select>
        </div>
        <div class="row hidden" id="rowPoseSeconds">
            <label><span id="lblPoseSeconds">Nh·∫≠p s·ªë gi√¢y c·∫£nh</span><span class="tooltip" id="tipPoseSeconds" data-tip="?">?</span></label>
            <input type="number" id="poseSeconds" value="4" min="0.1" step="0.1" oninput="togglePoseCustom(); updatePoseEst()">
        </div>
        <div class="row">
            <label><span id="lblFPS_pose">FPS g·ªëc</span><span class="tooltip" id="tipFPS_pose" data-tip="?">?</span></label>
            <input type="number" id="fpsPose" value="24" min="1" oninput="updatePoseEst(); updateJerkHint()">
            <div class="fps-presets">
                <button onclick="setField('fpsPose', 12); updatePoseEst(); updateJerkHint()">12</button>
                <button onclick="setField('fpsPose', 24); updatePoseEst(); updateJerkHint()">24</button>
                <button onclick="setField('fpsPose', 30); updatePoseEst(); updateJerkHint()">30</button>
                <button onclick="setField('fpsPose', 60); updatePoseEst(); updateJerkHint()">60</button>
            </div>
        </div>
        <div class="row">
            <label><span id="lblAnimStylePose">Lo·∫°i di·ªÖn ho·∫°t</span><span class="tooltip" id="tipAnimStylePose" data-tip="?">?</span></label>
            <select id="animStylePose" onchange="updatePoseEst(); updateJerkHint()"><option id="optPO1" value="1">On 1s</option><option id="optPO2" value="2" selected>On 2s</option><option id="optPO3" value="3">On 3s</option></select>
        </div>
        <div class="row">
            <label><span id="lblFocusTypePose">Lo·∫°i t√¢m ƒëi·ªÉm</span><span class="tooltip" id="tipFocusTypePose" data-tip="?">?</span></label>
            <select id="focusTypePose" onchange="togglePoseActions(); updatePoseEst()"><option id="optFocCharP" value="char">Nh√¢n v·∫≠t</option><option id="optFocObjP" value="obj">V·∫≠t th·ªÉ</option></select>
        </div>
        <div class="row">
            <label><span id="lblFocusActionPose">H√†nh ƒë·ªông c·ª• th·ªÉ</span><span class="tooltip" id="tipFocusActionPose" data-tip="?">?</span></label>
            <select id="focusActionChar" class="" onchange="updatePoseEst()"><option value="talk" id="actTalk">N√≥i chuy·ªán</option><option value="walk" id="actWalk">ƒêi b·ªô</option><option value="run" id="actRun">Ch·∫°y</option><option value="fight" id="actFight">ƒê√°nh nhau</option><option value="other" id="actOtherC">H√†nh ƒë·ªông kh√°c</option></select>
            <select id="focusActionObj" class="hidden" onchange="updatePoseEst()"><option value="fly" id="actFly">Bay</option><option value="fall" id="actFall">R∆°i</option><option value="break" id="actBreak">V·ª°/G√£y</option><option value="bounce" id="actBounce">N·∫£y l√™n/xu·ªëng</option><option value="scale" id="actScale">Ph√≥ng to/Thu nh·ªè</option><option value="other" id="actOtherO">H√†nh ƒë·ªông kh√°c</option></select>
        </div>
        <div class="row">
            <label><span id="lblCorePacingPose">Nh·ªãp t√¢m ƒëi·ªÉm</span><span class="tooltip" id="tipCorePacingPose" data-tip="?">?</span></label>
            <select id="corePacingPose" onchange="updatePoseEst()"><option id="optCpSuperSlowP" value="superslow">Super Slow</option><option id="optCpSlowmoP" value="slowmo">Slow Motion</option><option id="optCpSlowP" value="slow">Ch·∫≠m</option><option id="optCpNormalP" value="normal" selected>B√¨nh th∆∞·ªùng</option><option id="optCpFastP" value="fast">Nhanh</option><option id="optCpSuperFastP" value="superfast">C·ª±c nhanh</option><option id="optCpTimeSplashP" value="timesplash">Time Splash</option></select>
        </div>
        <div class="row">
            <label><span id="lblCurveTypePose">Lo·∫°i ƒë·ªì th·ªã</span><span class="tooltip" id="tipCurveTypePose" data-tip="?">?</span></label>
            <select id="curveTypePose" onchange="togglePoseCustom(); updatePoseEst()">
                <option id="optCvNoneP" value="linear">Kh√¥ng</option><option id="optCvEaseOutP" value="ease_out">ƒê·ªì th·ªã xu·ªëng</option><option id="optCvEaseInP" value="ease_in">ƒê·ªì th·ªã l√™n</option><option id="optCvClimaxP" value="climax">ƒêi·ªÉm cao tr√†o</option><option id="optCvLowPointP" value="low_point">ƒêi·ªÉm tr·∫ßm</option><option id="optCvWaveP" value="wave">S√≥ng (Cao/th·∫•p c·∫°nh nhau)</option><option id="optCvCustomP" value="custom">T√πy ch·ªânh (Custom)</option>
            </select>
            
            <div id="customEditorWrap_pose" class="custom-editor hidden">
                <div class="editor-controls">
                    <div class="editor-controls-left">
                        <span id="lblEditorP">B·ªô d·ª±ng ƒê·ªì th·ªã</span>
                        <label class="checkbox-lbl"><input type="checkbox" id="smoothCurve_pose" checked> <span id="lblSmoothP">ƒê∆∞·ªùng m∆∞·ª£t</span></label>
                        <label class="checkbox-lbl"><input type="checkbox" id="lockEnd_pose" checked> <span id="lblLockP">Kh√≥a m√∫t</span></label>
                    </div>
                    <div class="editor-btn-group">
                        <button class="editor-btn btn-reset" onclick="resetCustomPoints('pose')" id="btnResetP">Kh√¥i ph·ª•c</button>
                        <button class="editor-btn" onclick="modifyCustomPoints('pose', 1)">+ ƒêi·ªÉm</button>
                        <button class="editor-btn" onclick="modifyCustomPoints('pose', -1)">- ƒêi·ªÉm</button>
                    </div>
                </div>
                <div class="editor-canvas-wrap"><canvas id="customCanvas_pose"></canvas></div>
            </div>
            <div id="warnCustomPose" class="warning hidden" style="color:#ff6b6b; border-color:#ff6b6b;"></div>
        </div>
        <div class="row">
            <label><span id="lblSubPose">Th√™m Pose ph·ª• tr·ª£ (In-betweens)</span><span class="tooltip" id="tipSubPose" data-tip="?">?</span></label>
            <select id="subPoseToggle" onchange="togglePoseSettings(); updatePoseEst()"><option id="optNo" value="no">Kh√¥ng</option><option id="optYes" value="yes">C√≥</option></select>
        </div>
        <div class="row hidden" id="rowSubPoseLogic">
            <label><span id="lblSubPoseLogic">Quy t·∫Øc Pose ph·ª• tr·ª£</span><span class="tooltip" id="tipSubPoseLogic" data-tip="?">?</span></label>
            <select id="subPoseLogic" onchange="updatePoseEst()"><option id="optSpRandom" value="random">X√°c su·∫•t ng·∫´u nhi√™n</option><option value="1">1 Pose ph·ª•</option><option value="2">2 Pose ph·ª•</option><option value="3">3 Pose ph·ª•</option><option value="4">4 Pose ph·ª•</option></select>
        </div>
        
        <div class="row" id="rowJerkiness">
            <label><span id="lblJerkiness">ƒê·ªô gi·∫≠t - kh·ª±ng (Stutter/Hold)</span><span class="tooltip" id="tipJerkiness" data-tip="?">?</span></label>
            <select id="jerkToggle" onchange="togglePoseSettings(); updatePoseEst()"><option id="optJerkNo" value="no">Kh√¥ng</option><option id="optJerkSec" value="sec">Theo Gi√¢y</option><option id="optJerkFrame" value="frame">Theo Frame</option></select>
            <div id="jerkInputBlock" class="hidden" style="margin-top: 10px;">
                <input type="number" id="jerkValue" value="2" min="0" step="0.1" oninput="updatePoseEst()">
                <span id="jerkHint" class="note-text hidden"></span>
            </div>
        </div>
        <div class="result" id="poseOutput">‚Äî</div>
        <div class="warning" id="warnMathModelPose">‚ö† L∆∞u √Ω: H·ªá th·ªëng ch·ªâ t√≠nh to√°n g·ª£i √Ω v·ªã tr√≠ l√Ω thuy·∫øt, m·∫≠t ƒë·ªô th·ª±c t·∫ø ph·ª• thu·ªôc b·∫£n v·∫Ω.</div>
    </div>

    <div id="renderMode" class="hidden">
        <div class="tab-desc" id="descRender">∆Ø·ªõc t√≠nh t·ªïng th·ªùi gian xu·∫•t file (Render) c·ªßa to√†n b·ªô d·ª± √°n d·ª±a tr√™n th·ªùi gian ch·∫°y 1 khung h√¨nh.</div>
        <div class="row">
            <label><span id="lblTotalFrames">T·ªïng s·ªë frame</span><span class="tooltip" id="tipTotalFrames" data-tip="?">?</span></label>
            <input type="number" id="totalFrames" min="0" oninput="updateRender()">
        </div>
        <div class="row">
            <label><span id="lblRenderPerFrame">Th·ªùi gian render 1 frame (gi√¢y)</span><span class="tooltip" id="tipRenderPerFrame" data-tip="?">?</span></label>
            <input type="number" id="renderPerFrame" step="0.01" min="0" oninput="updateRender()">
        </div>
        <div class="result" id="renderOutput">‚Äî</div>
        <div class="warning" id="warningTextRender">‚ö† Ch·ªâ d√πng ƒë·ªÉ tham kh·∫£o. M·∫≠t ƒë·ªô chi ti·∫øt c·∫£nh th·ª±c t·∫ø s·∫Ω l√†m ƒë·ªïi th·ªùi gian.</div>
    </div>
</div>

<footer>
    <span id="lblLanguage">Ng√¥n ng·ªØ:</span>
    <select onchange="changeLang(this.value)"><option value="vi">üáªüá≥ VI</option><option value="en">üá¨üáß EN</option></select>
</footer>

<script>
// Canvas Polyfill
if (!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
        if (w < 2 * r) r = w / 2; if (h < 2 * r) r = h / 2;
        this.beginPath(); this.moveTo(x + r, y); this.arcTo(x + w, y, x + w, y + h, r);
        this.arcTo(x + w, y + h, x, y + h, r); this.arcTo(x, y + h, x, y, r); this.arcTo(x, y, x + w, y, r);
        this.closePath(); return this;
    }
}

let currentLang = "vi";

const i18n = {
    vi: {
        introText: "C√¥ng c·ª• ƒëa nƒÉng h·ªó tr·ª£ Animation Timing, T√≠nh to√°n Frame v√† Render.",
        tabConvert: "Time / Frame", tabAnime: "Anime, Toon Frame", tabPose: "D·ª± t√≠nh Pose", tabRender: "Render Time",
        descConvert: "C√¥ng c·ª• chuy·ªÉn ƒë·ªïi qua l·∫°i gi·ªØa th·ªùi l∆∞·ª£ng (Gi√¢y/Ph√∫t/Gi·ªù) v√† S·ªë khung h√¨nh (Frames) theo t·ªëc ƒë·ªô chu·∫©n.",
        descAnime: "Ph√¢n b·ªï kho·∫£ng c√°ch c√°c Keyframe theo quy t·∫Øc Animation (On 1s, 2s, 3s) v√† n·ªôi suy nh·ªãp ƒë·ªô c·∫£nh.",
        descPose: "T·ª± ƒë·ªông ∆∞·ªõc t√≠nh s·ªë l∆∞·ª£ng Pose ch√≠nh v√† Pose ph·ª• tr·ª£ (In-betweens) ph·ª• thu·ªôc v√†o h√†nh ƒë·ªông c·ª• th·ªÉ v√† th·ªùi l∆∞·ª£ng.",
        descRender: "∆Ø·ªõc t√≠nh t·ªïng th·ªùi gian xu·∫•t file (Render) c·ªßa to√†n b·ªô d·ª± √°n d·ª±a tr√™n th·ªùi gian ch·∫°y 1 khung h√¨nh.",

        tipMode: "Ch·ªçn lo·∫°i chuy·ªÉn ƒë·ªïi.", tipFPS_conv: "T·ªëc ƒë·ªô khung h√¨nh (th∆∞·ªùng l√† 24).", tipInput: "Nh·∫≠p t·ªïng s·ªë l∆∞·ª£ng t√≠nh to√°n.",
        tipAnimStyle: "Quy ƒë·ªãnh s·ªë b·∫£n v·∫Ω tr√™n gi√¢y:\n‚Ä¢ On 1s: 24 fps (M∆∞·ª£t).\n‚Ä¢ On 2s: 12 fps (Anime).\n‚Ä¢ On 3s: 8 fps (Ch·∫≠m).",
        tipFPS_anime: "Khung h√¨nh ti√™u chu·∫©n c·ªßa d·ª± √°n.", tipCorePacingAnime: "T·ªëc ƒë·ªô di·ªÖn ho·∫°t c·∫£nh.",
        tipCurveTypeAnime: "ƒê∆∞·ªùng cong gia t·ªëc (Easing):\n‚Ä¢ T√πy ch·ªânh: T·ª± v·∫Ω ƒë·ªì th·ªã (Y√™u c·∫ßu >3s v√† Logic Nghi√™m ng·∫∑t).",
        tipFocus: "V·∫≠t th·ªÉ ƒëang ƒë·ª©ng im hay di chuy·ªÉn.", tipPose: "T·ªïng s·ªë Pose ch√≠nh c·∫ßn v·∫Ω.", tipFrameRange: "Gi·ªõi h·∫°n th·ªùi gian c·ªßa ƒëo·∫°n di·ªÖn ho·∫°t.",
        tipCalcLogic: "‚Ä¢ Nghi√™m ng·∫∑t: C·ªë ƒë·ªãnh to√°n h·ªçc.\n‚Ä¢ Ng·∫´u nhi√™n: Th√™m sai l·ªách t·ª± nhi√™n.", tipPoseCalcMode: "T·ª± b·ªãa s·ªë gi√¢y hay ·∫•n ƒë·ªãnh tr∆∞·ªõc.", tipPoseSeconds: "ƒê·ªô d√†i c·∫£nh (gi√¢y).",
        tipFPS_pose: "Khung h√¨nh ti√™u chu·∫©n c·ªßa d·ª± √°n.", tipAnimStylePose: "S·ªë frame ƒë·ªÉ gi·ªØ 1 b·∫£n v·∫Ω.", tipFocusTypePose: "Lo·∫°i ƒë·ªëi t∆∞·ª£ng ch√≠nh.",
        tipFocusActionPose: "H√†nh ƒë·ªông ƒë·ªÉ thu·∫≠t to√°n ƒëo ƒë·ªô kh√≥.", tipCorePacingPose: "Nh·ªãp h√†nh ƒë·ªông t·ªïng th·ªÉ.",
        tipCurveTypePose: "Quy lu·∫≠t Easing.\n‚Ä¢ T√πy ch·ªânh: T·ª± v·∫Ω (Y√™u c·∫ßu >3s v√† Theo gi√¢y).",
        tipSubPose: "T·ª± ƒë·ªông ch√®n In-betweens.", tipSubPoseLogic: "S·ªë l∆∞·ª£ng b·∫£n v·∫Ω ph·ª• ch√®n gi·ªØa.", tipJerkiness: "K·ªπ thu·∫≠t Hold ·ªü ƒëi·ªÉm ch·∫°m.",
        tipTotalFrames: "T·ªïng frame xu·∫•t.", tipRenderPerFrame: "Th·ªùi gian m√°y render 1 frame.",

        lblMode: "Lo·∫°i t√≠nh", optF2T: "Frame ‚Üí Time", optT2F: "Time ‚Üí Frame",
        lblFPS_conv: "FPS", lblInput: "S·ªë khung h√¨nh/th·ªùi gian", optSec: "Gi√¢y", optMin: "Ph√∫t", optHour: "Gi·ªù",
        lblAnimStyle: "Ki·ªÉu di·ªÖn ho·∫°t", optOn1s: "On 1s (M∆∞·ª£t / H√†nh ƒë·ªông)", optOn2s: "On 2s (Chu·∫©n Anime)", optOn3s: "On 3s (Tƒ©nh / Ch·∫≠m)",
        lblFPS_anime: "FPS g·ªëc", lblCorePacingAnime: "Nh·ªãp t√¢m ƒëi·ªÉm", 
        optCpSuperSlowA: "Super Slow", optCpSlowmoA: "Slow Motion", optCpSlowA: "Ch·∫≠m", optCpNormalA: "B√¨nh th∆∞·ªùng", optCpFastA: "Nhanh", optCpSuperFastA: "C·ª±c nhanh", optCpTimeSplashA: "Time Splash",
        lblCurveTypeAnime: "Lo·∫°i ƒë·ªì th·ªã (Ph√¢n b·ªï)", optCvNoneA: "Kh√¥ng (ƒê·ªÅu)", optCvEaseOutA: "ƒê·ªì th·ªã xu·ªëng (Ch·∫≠m d·∫ßn)", optCvEaseInA: "ƒê·ªì th·ªã l√™n (Nhanh d·∫ßn)", optCvClimaxA: "ƒêi·ªÉm cao tr√†o (Nhanh gi·ªØa)", optCvLowPointA: "ƒêi·ªÉm tr·∫ßm (Ch·∫≠m gi·ªØa)", optCvWaveA: "S√≥ng (Nhanh ch·∫≠m xen k·∫Ω)", optCvCustomA: "T√πy ch·ªânh (Custom)",
        lblFocus: "T√¢m ƒëi·ªÉm & Tr·∫°ng th√°i", optFocScene: "C·∫£nh", optFocChar: "Nh√¢n v·∫≠t/V·∫≠t th·ªÉ", optStateStatic: "Tƒ©nh", optStateDynamic: "ƒê·ªông",
        lblPose: "S·ªë Pose ch√≠nh", lblFrameRange: "Frame B·∫Øt ƒë·∫ßu - K·∫øt th√∫c", 
        lblCalcLogic: "Logic t√≠nh to√°n", optLogicStrict: "To√°n h·ªçc nghi√™m ng·∫∑t", optLogicRandom: "X√°c su·∫•t ng·∫´u nhi√™n",
        warnMathModelAnime: "‚ö† L∆∞u √Ω: M√¥ h√¨nh ƒë·ªì th·ªã v√† to√°n h·ªçc ch·ªâ mang t√≠nh ch·∫•t g·ª£i √Ω tham kh·∫£o.",
        lblPoseCalcMode: "C√°ch t√≠nh to√°n", optPcalcRandom: "X√°c su·∫•t ng·∫´u nhi√™n", optPcalcSeconds: "Theo s·ªë gi√¢y c·∫£nh",
        lblPoseSeconds: "Nh·∫≠p s·ªë gi√¢y c·∫£nh", lblFPS_pose: "FPS g·ªëc", lblAnimStylePose: "Lo·∫°i di·ªÖn ho·∫°t",
        lblFocusTypePose: "Lo·∫°i t√¢m ƒëi·ªÉm", optFocCharP: "Nh√¢n v·∫≠t", optFocObjP: "V·∫≠t th·ªÉ",
        lblFocusActionPose: "H√†nh ƒë·ªông c·ª• th·ªÉ", actTalk: "N√≥i chuy·ªán", actWalk: "ƒêi b·ªô", actRun: "Ch·∫°y", actFight: "ƒê√°nh nhau", actOtherC: "Kh√°c", actFly: "Bay", actFall: "R∆°i", actBreak: "V·ª°/G√£y", actBounce: "N·∫£y", actScale: "Scale", actOtherO: "Kh√°c",
        lblCorePacingPose: "Nh·ªãp t√¢m ƒëi·ªÉm", optCpSuperSlowP: "Super Slow", optCpSlowmoP: "Slow Motion", optCpSlowP: "Ch·∫≠m", optCpNormalP: "B√¨nh th∆∞·ªùng", optCpFastP: "Nhanh", optCpSuperFastP: "C·ª±c nhanh", optCpTimeSplashP: "Time Splash",
        lblCurveTypePose: "Lo·∫°i ƒë·ªì th·ªã", optCvNoneP: "Kh√¥ng", optCvEaseOutP: "ƒê·ªì th·ªã xu·ªëng", optCvEaseInP: "ƒê·ªì th·ªã l√™n", optCvClimaxP: "ƒêi·ªÉm cao tr√†o", optCvLowPointP: "ƒêi·ªÉm tr·∫ßm", optCvWaveP: "S√≥ng", optCvCustomP: "T√πy ch·ªânh (Custom)",
        lblSubPose: "Pose ph·ª• (In-betweens)", optNo: "Kh√¥ng", optYes: "C√≥",
        lblSubPoseLogic: "Quy t·∫Øc Pose ph·ª•", optSpRandom: "Ng·∫´u nhi√™n",
        lblJerkiness: "Gi·∫≠t/Kh·ª±ng (Hold)", optJerkNo: "Kh√¥ng", optJerkFrame: "Theo Frame", optJerkSec: "Theo Gi√¢y",
        warnMathModelPose: "‚ö† L∆∞u √Ω: H·ªá th·ªëng ch·ªâ t√≠nh to√°n g·ª£i √Ω v·ªã tr√≠ l√Ω thuy·∫øt, m·∫≠t ƒë·ªô th·ª±c t·∫ø ph·ª• thu·ªôc b·∫£n v·∫Ω.",
        lblTotalFrames: "T·ªïng frame", lblRenderPerFrame: "Th·ªùi gian render 1 frame (gi√¢y)",
        warningTextRender: "‚ö† Th·ª±c t·∫ø c·∫£nh n·∫∑ng s·∫Ω thay ƒë·ªïi th·ªùi gian.", lblLanguage: "Ng√¥n ng·ªØ:",
        
        dynFrames: "Frames", dynSec: "gi√¢y", dynKeysSugg: "G·ª£i √Ω Keyframe", dynEstPoses: "Pose ∆∞·ªõc t√≠nh",
        dynSubPose: "Pose ph·ª•", dynHold: "Gi·∫≠t/Kh·ª±ng (Hold)", dynHoldMsg1: "Khuy√™n d√πng gi·ªØ th√™m", dynHoldMsg2: "t·∫°i ƒëi·ªÉm ch·∫°m.",
        dynHintFrames: "G·ª£i √Ω h·ª£p l√Ω: ",
        
        dynClampWarn1: "‚ö†Ô∏è L∆∞u √Ω: Th·ªùi gian c·∫£nh qu√° ng·∫Øn. Keyframe cu·ªëi b·ªã √©p v√†o frame ", dynClampWarn2: " (ph√° v·ª° chu·∫©n nh·ªãp On ", dynClampWarn3: "s).<br>‚ûî G·ª£i √Ω: K√©o d√†i c·∫£nh ho·∫∑c ƒë·ªïi sang nh·ªãp On 1s/2s.",
        dynGraphLimitWarn: "‚ö†Ô∏è C·∫£nh b√°o: V∆∞·ª£t qu√° 25 gi√¢y. ƒê√£ ·∫©n bi·ªÉu ƒë·ªì ƒë·ªì th·ªã ƒë·ªÉ t·ªëi ∆∞u h√≥a hi·ªáu su·∫•t thi·∫øt b·ªã.",
        
        lblVisualGraph: "T·ªïng quan (Gia t·ªëc)", tipVisualGraph: "ƒê·ªì th·ªã bi·ªÉu di·ªÖn ph√¢n b·ªï t·ªëc ƒë·ªô l√Ω thuy·∫øt. ƒê∆∞·ªùng n√©t ƒë·ª©t l√† m·ªëc t·ªëc ƒë·ªô ƒë·ªÅu ƒë·∫∑n.",
        lblDataGraph: "D√≤ng th·ªùi gian (Keyframe)", tipDataGraph: "V·ªã tr√≠ th·ª±c t·∫ø c·ªßa t·ª´ng b·∫£n v·∫Ω tr√™n tr·ª•c th·ªùi gian (K√©o sang ph·∫£i ƒë·ªÉ xem h·∫øt).",
        phStartFrame: "B·∫Øt ƒë·∫ßu (vd: 1)", phEndFrame: "K·∫øt th√∫c (vd: 100)",
        legendMainKey: "Key ch√≠nh", legendSubKey: "Key ph·ª•",
        lblEditorA: "B·ªô d·ª±ng ƒê·ªì th·ªã t·ª± do", lblEditorP: "B·ªô d·ª±ng ƒê·ªì th·ªã t·ª± do", lblLockA: "Kh√≥a m√∫t", lblLockP: "Kh√≥a m√∫t", lblSmoothA: "ƒê∆∞·ªùng m∆∞·ª£t", lblSmoothP: "ƒê∆∞·ªùng m∆∞·ª£t", btnResetA: "Kh√¥i ph·ª•c", btnResetP: "Kh√¥i ph·ª•c",
        
        warnCustomAnime: "‚ö†Ô∏è T√πy ch·ªânh kh√¥ng kh·∫£ d·ª•ng: \"Logic t√≠nh to√°n\" c·∫ßn ch·ªçn ch·∫ø ƒë·ªô To√°n h·ªçc nghi√™m ng·∫∑t v√† th·ªùi l∆∞·ª£ng t·ª´ 3 gi√¢y.",
        warnCustomPose: "‚ö†Ô∏è T√πy ch·ªânh kh√¥ng kh·∫£ d·ª•ng: \"C√°ch t√≠nh to√°n\" c·∫ßn ch·ªçn ch·∫ø ƒë·ªô Theo S·ªë Gi√¢y C·∫£nh v√† th·ªùi l∆∞·ª£ng t·ª´ 3 gi√¢y."
    },
    en: {
        introText: "Versatile tool for Animation Timing, Frame calculations, and Render estimation.",
        tabConvert: "Time / Frame", tabAnime: "Anime, Toon Frame", tabPose: "Pose Estimator", tabRender: "Render Time",
        descConvert: "Tool to seamlessly convert between time duration (Sec/Min/Hour) and total Frames based on FPS.",
        descAnime: "Distribute Keyframes using standard Animation rules (On 1s, 2s, 3s) and calculate scene pacing.",
        descPose: "Automatically estimate main Poses and In-betweens depending on specific action types and duration.",
        descRender: "Estimate the total Render time needed for your project based on a single frame's processing time.",
        
        tipMode: "Select conversion type.", tipFPS_conv: "FPS determines the speed.", tipInput: "Enter the value to compute.",
        tipAnimStyle: "Defines keys per second.", tipFPS_anime: "Standard framerate.", tipCorePacingAnime: "Overall scene speed.",
        tipCurveTypeAnime: "Acceleration curve.\n‚Ä¢ Custom: Draw your own (Requires >3s & Strict Logic).",
        tipFocus: "Dynamic (moving) or Static (still).", tipPose: "Number of main poses.", tipFrameRange: "Time boundary.",
        tipCalcLogic: "Strict math or Random deviation.", tipPoseCalcMode: "Random or Custom seconds.", tipPoseSeconds: "Desired duration.",
        tipFPS_pose: "Standard framerate.", tipAnimStylePose: "Keyframe density.", tipFocusTypePose: "Character or Object.",
        tipFocusActionPose: "Specific action.", tipCorePacingPose: "Overall speed.",
        tipCurveTypePose: "Acceleration curve.\n‚Ä¢ Custom: Draw your own (Requires >3s & Fixed Seconds).",
        tipSubPose: "Generate In-between poses.", tipSubPoseLogic: "In-between padding rule.", tipJerkiness: "Hold frames at impact.",
        tipTotalFrames: "Total frames to render.", tipRenderPerFrame: "Actual time to render a single frame.",

        lblMode: "Mode", optF2T: "Frame ‚Üí Time", optT2F: "Time ‚Üí Frame",
        lblFPS_conv: "FPS", lblInput: "Input Value", optSec: "Seconds", optMin: "Minutes", optHour: "Hours",
        lblAnimStyle: "Anim Style", optOn1s: "On 1s", optOn2s: "On 2s", optOn3s: "On 3s",
        lblFPS_anime: "Base FPS", lblCorePacingAnime: "Core Pacing", 
        optCpSuperSlowA: "Super Slow", optCpSlowmoA: "Slow Motion", optCpSlowA: "Slow", optCpNormalA: "Normal", optCpFastA: "Fast", optCpSuperFastA: "Super Fast", optCpTimeSplashA: "Time Splash",
        lblCurveTypeAnime: "Curve Type", optCvNoneA: "None (Linear)", optCvEaseOutA: "Ease Out", optCvEaseInA: "Ease In", optCvClimaxA: "Climax", optCvLowPointA: "Low Point", optCvWaveA: "Wave", optCvCustomA: "Custom",
        lblFocus: "Focus & State", optFocScene: "Scene", optFocChar: "Character/Object", optStateStatic: "Static", optStateDynamic: "Dynamic",
        lblPose: "Pose Count", lblFrameRange: "Start - End Frame", 
        lblCalcLogic: "Logic", optLogicStrict: "Strict Math", optLogicRandom: "Random Prob",
        warnMathModelAnime: "‚ö† Note: Graph models are for theoretical reference only.",
        lblPoseCalcMode: "Calc Mode", optPcalcRandom: "Random Prob", optPcalcSeconds: "By Scene Seconds",
        lblPoseSeconds: "Enter Seconds", lblFPS_pose: "Base FPS", lblAnimStylePose: "Anim Style",
        lblFocusTypePose: "Focus Type", optFocCharP: "Character", optFocObjP: "Object",
        lblFocusActionPose: "Specific Action", actTalk: "Talking", actWalk: "Walking", actRun: "Running", actFight: "Fighting", actOtherC: "Other Action", actFly: "Flying", actFall: "Falling", actBreak: "Breaking", actBounce: "Bouncing", actScale: "Scaling", actOtherO: "Other Action",
        lblCorePacingPose: "Core Pacing", optCpSuperSlowP: "Super Slow", optCpSlowmoP: "Slow Motion", optCpSlowP: "Slow", optCpNormalP: "Normal", optCpFastP: "Fast", optCpSuperFastP: "Super Fast", optCpTimeSplashP: "Time Splash",
        lblCurveTypePose: "Curve Type", optCvNoneP: "None", optCvEaseOutP: "Ease Out", optCvEaseInP: "Ease In", optCvClimaxP: "Climax", optCvLowPointP: "Low Point", optCvWaveP: "Wave", optCvCustomP: "Custom",
        lblSubPose: "Add In-betweens", optNo: "No", optYes: "Yes", lblSubPoseLogic: "In-between Logic", optSpRandom: "Random Prob",
        lblJerkiness: "Stutter / Hold", optJerkNo: "No", optJerkFrame: "By Frames", optJerkSec: "By Seconds",
        warnMathModelPose: "‚ö† Note: Theoretical suggestion; real density depends on the drawing.",
        lblTotalFrames: "Total Frames", lblRenderPerFrame: "Time per frame",
        warningTextRender: "‚ö† Reference only.", lblLanguage: "Language:",
        
        dynFrames: "Frames", dynSec: "sec", dynKeysSugg: "Suggested Keys", dynEstPoses: "Est. Main Poses", dynSubPose: "Sub Poses", dynHold: "Hold Effect", dynHoldMsg1: "Suggested holding", dynHoldMsg2: "at impact.", dynHintFrames: "Suggested range: ",
        dynClampWarn1: "‚ö†Ô∏è Note: Scene duration is too short. The last key was forced to frame ", dynClampWarn2: " (breaking the On ", dynClampWarn3: "s rhythm).<br>‚ûî Fix: Increase scene duration or switch to On 1s/2s.",
        dynGraphLimitWarn: "‚ö†Ô∏è Warning: Scene > 25s. Graphs disabled to optimize device performance.",
        
        lblVisualGraph: "Overview (Acceleration)", tipVisualGraph: "Theoretical speed distribution. Dotted line is constant speed.", 
        lblDataGraph: "Timeline (Keyframes)", tipDataGraph: "Actual frame placement on the timeline (Scrollable horizontally).",
        phStartFrame: "Start (e.g., 1)", phEndFrame: "End (e.g., 100)", legendMainKey: "Main Key", legendSubKey: "Sub Key",
        lblEditorA: "Free Curve Editor", lblEditorP: "Free Curve Editor", lblLockA: "Lock Ends", lblLockP: "Lock Ends", lblSmoothA: "Smooth", lblSmoothP: "Smooth", btnResetA: "Reset", btnResetP: "Reset",
        
        warnCustomAnime: "‚ö†Ô∏è Custom not available: \"Logic\" must be set to Strict Math and duration >= 3 seconds.",
        warnCustomPose: "‚ö†Ô∏è Custom not available: \"Calc Mode\" must be set to By Scene Seconds and duration >= 3 seconds."
    }
};

// SPLINE & CUSTOM CURVE LOGIC
let customData = {
    anime: { points: [{x:0, y:0}, {x:0.33, y:0.8}, {x:0.66, y:0.2}, {x:1, y:1}], activeNode: null },
    pose: { points: [{x:0, y:0}, {x:0.5, y:0.8}, {x:1, y:1}], activeNode: null }
};

function resetCustomPoints(tab) {
    if (tab === 'anime') {
        customData.anime.points = [{x:0, y:0}, {x:0.33, y:0.8}, {x:0.66, y:0.2}, {x:1, y:1}];
    } else {
        customData.pose.points = [{x:0, y:0}, {x:0.5, y:0.8}, {x:1, y:1}];
    }
    drawCustomEditor(tab);
    if(tab === 'anime') updateAnime(); else updatePoseEst();
}

function lerpCustomCurve(x, points) {
    if (x <= points[0].x) return points[0].y;
    if (x >= points[points.length-1].x) return points[points.length-1].y;
    for (let i=0; i<points.length-1; i++) {
        if (x >= points[i].x && x <= points[i+1].x) {
            let t = (x - points[i].x) / (points[i+1].x - points[i].x);
            return points[i].y + t * (points[i+1].y - points[i].y);
        }
    }
    return x;
}

function splineCustomCurve(x, points) {
    if (x <= points[0].x) return points[0].y;
    if (x >= points[points.length-1].x) return points[points.length-1].y;
    
    let i = 0;
    while (i < points.length - 2 && x > points[i+1].x) i++;
    
    let p0 = points[Math.max(0, i - 1)];
    let p1 = points[i];
    let p2 = points[i + 1];
    let p3 = points[Math.min(points.length - 1, i + 2)];
    
    let t = (x - p1.x) / (p2.x - p1.x);
    let t2 = t * t;
    let t3 = t2 * t;
    
    let v0 = (p2.y - p0.y) * 0.5;
    let v1 = (p3.y - p1.y) * 0.5;
    
    let rawVal = (2 * p1.y - 2 * p2.y + v0 + v1) * t3 + (-3 * p1.y + 3 * p2.y - 2 * v0 - v1) * t2 + v0 * t + p1.y;
    return Math.max(0, Math.min(1, rawVal)); 
}

function getPacingCurve(x, type, tab) {
    if(type === 'custom') {
        let isSmooth = document.getElementById("smoothCurve_" + tab) && document.getElementById("smoothCurve_" + tab).checked;
        return isSmooth ? splineCustomCurve(x, customData[tab].points) : lerpCustomCurve(x, customData[tab].points);
    }
    if(type === 'ease_in') return x * x * x; 
    if(type === 'ease_out') return 1 - Math.pow(1 - x, 3);
    if(type === 'climax') return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2;
    if(type === 'low_point') return x < 0.5 ? Math.pow(2 * x, 1/3) / 2 : 1 - Math.pow(-2 * x + 2, 1/3) / 2;
    if(type === 'wave') return x + 0.1 * Math.sin(x * Math.PI * 4);
    return x;
}

function drawCustomEditor(tab) {
    let canvas = document.getElementById("customCanvas_" + tab); if(!canvas) return;
    let wrap = canvas.parentElement; let dpr = window.devicePixelRatio || 1;
    let w = wrap.clientWidth; let h = wrap.clientHeight;
    if(canvas.width !== w * dpr) {
        canvas.width = w * dpr; canvas.height = h * dpr;
        canvas.style.width = w + "px"; canvas.style.height = h + "px";
        canvas.getContext("2d").setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    let ctx = canvas.getContext("2d"); ctx.clearRect(0,0,w,h);
    let pad = 20; let usableW = w - pad*2; let usableH = h - pad*2;
    
    ctx.strokeStyle = "rgba(30, 58, 95, 0.5)"; ctx.lineWidth = 1; ctx.beginPath();
    ctx.moveTo(pad, pad); ctx.lineTo(pad, h-pad); ctx.lineTo(w-pad, h-pad); ctx.stroke();
    
    let pts = customData[tab].points; 
    let isLocked = document.getElementById("lockEnd_" + tab).checked;
    let isSmooth = document.getElementById("smoothCurve_" + tab).checked;
    
    ctx.beginPath();
    if (isSmooth) {
        for(let i=0; i<=100; i++) {
            let x = i/100;
            let valY = splineCustomCurve(x, pts);
            let px = pad + x * usableW; let py = h - pad - valY * usableH;
            if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
        }
    } else {
        pts.forEach((p, i) => {
            let px = pad + p.x * usableW; let py = h - pad - p.y * usableH;
            if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
        });
    }
    ctx.strokeStyle = "#ffcc66"; ctx.lineWidth = 2.5; ctx.lineCap="round"; ctx.lineJoin="round"; ctx.stroke();
    
    pts.forEach((p, i) => {
        let px = pad + p.x * usableW; let py = h - pad - p.y * usableH;
        ctx.beginPath(); ctx.arc(px, py, 6, 0, Math.PI*2);
        let isEndNode = (i===0 || i===pts.length-1);
        ctx.fillStyle = (isEndNode && isLocked) ? "#1e3a5f" : "#00ccff";
        ctx.fill(); ctx.lineWidth=2; ctx.strokeStyle="#fff"; ctx.stroke();
    });
}

function initCustomCanvas(tab) {
    let canvas = document.getElementById("customCanvas_" + tab);
    if(!canvas || canvas.dataset.initialized) return; canvas.dataset.initialized = "true";
    let isDragging = false;
    
    function getMousePos(e) {
        let rect = canvas.getBoundingClientRect();
        let clientX = e.touches ? e.touches[0].clientX : e.clientX;
        let clientY = e.touches ? e.touches[0].clientY : e.clientY;
        return { x: clientX - rect.left, y: clientY - rect.top };
    }
    
    function handleDown(e) {
        e.preventDefault(); let pos = getMousePos(e);
        let pad = 20; let usableW = canvas.clientWidth - pad*2; let usableH = canvas.clientHeight - pad*2;
        let pts = customData[tab].points; let isLocked = document.getElementById("lockEnd_" + tab).checked;
        
        let startIdx = isLocked ? 1 : 0; let endIdx = isLocked ? pts.length - 1 : pts.length;
        for (let i = startIdx; i < endIdx; i++) {
            let px = pad + pts[i].x * usableW; let py = canvas.clientHeight - pad - pts[i].y * usableH;
            if (Math.hypot(pos.x - px, pos.y - py) < 20) { isDragging = true; customData[tab].activeNode = i; break; }
        }
    }
    
    function handleMove(e) {
        if (!isDragging || customData[tab].activeNode === null) return;
        e.preventDefault(); let pos = getMousePos(e);
        let pad = 20; let usableW = canvas.clientWidth - pad*2; let usableH = canvas.clientHeight - pad*2;
        let i = customData[tab].activeNode; let pts = customData[tab].points;
        let newX = (pos.x - pad) / usableW; let newY = (canvas.clientHeight - pad - pos.y) / usableH;
        
        if (i === 0) {
            pts[i].x = 0; pts[i].y = Math.max(0, Math.min(1, newY));
        } else if (i === pts.length - 1) {
            pts[i].x = 1; pts[i].y = Math.max(0, Math.min(1, newY));
        } else {
            let minX = pts[i-1].x + 0.05; let maxX = pts[i+1].x - 0.05;
            pts[i].x = Math.max(minX, Math.min(maxX, newX)); pts[i].y = Math.max(0, Math.min(1, newY));
        }
        drawCustomEditor(tab); if(tab === 'anime') updateAnime(); else updatePoseEst();
    }
    
    function handleUp(e) { isDragging = false; customData[tab].activeNode = null; }

    canvas.addEventListener('mousedown', handleDown); canvas.addEventListener('mousemove', handleMove); window.addEventListener('mouseup', handleUp);
    canvas.addEventListener('touchstart', handleDown, {passive:false}); canvas.addEventListener('touchmove', handleMove, {passive:false}); window.addEventListener('touchend', handleUp);
    document.getElementById("lockEnd_" + tab).addEventListener('change', () => drawCustomEditor(tab));
    document.getElementById("smoothCurve_" + tab).addEventListener('change', () => { drawCustomEditor(tab); if(tab==='anime') updateAnime(); else updatePoseEst(); });
}

function modifyCustomPoints(tab, delta) {
    let pts = customData[tab].points;
    if (delta > 0 && pts.length < 6) {
        let newPts = [pts[0]];
        for(let i=1; i<pts.length; i++) {
            newPts.push({ x: (pts[i-1].x + pts[i].x)/2, y: (pts[i-1].y + pts[i].y)/2 });
            newPts.push(pts[i]);
        }
        while(newPts.length > pts.length + 1 && newPts.length > 6) newPts.splice(2, 1);
        customData[tab].points = newPts;
    } else if (delta < 0 && pts.length > 3) {
        pts.splice(pts.length-2, 1);
    }
    drawCustomEditor(tab); if(tab === 'anime') updateAnime(); else updatePoseEst();
}

function toggleAnimeCustom() {
    let curve = document.getElementById("curveTypeAnime").value; let logic = document.getElementById("calcLogic").value;
    let fps = parseFloat(document.getElementById("fpsAnime").value) || 24; let sf = parseInt(document.getElementById("startFrame").value) || 1; let ef = parseInt(document.getElementById("endFrame").value) || 100;
    let timeSec = (ef - sf + 1) / fps; let wrap = document.getElementById("customEditorWrap_anime"); let warn = document.getElementById("warnCustomAnime");
    if (curve === "custom") {
        wrap.classList.remove("hidden");
        if (logic !== "strict" || timeSec < 3) { wrap.classList.add("disabled"); warn.classList.remove("hidden");
        } else { wrap.classList.remove("disabled"); warn.classList.add("hidden"); initCustomCanvas('anime'); requestAnimationFrame(() => drawCustomEditor('anime')); }
    } else { wrap.classList.add("hidden"); warn.classList.add("hidden"); }
}

function togglePoseCustom() {
    let curve = document.getElementById("curveTypePose").value; let mode = document.getElementById("poseCalcMode").value;
    let sec = parseFloat(document.getElementById("poseSeconds").value) || 0;
    let wrap = document.getElementById("customEditorWrap_pose"); let warn = document.getElementById("warnCustomPose");
    if (curve === "custom") {
        wrap.classList.remove("hidden");
        if (mode !== "seconds" || sec < 3) { wrap.classList.add("disabled"); warn.classList.remove("hidden");
        } else { wrap.classList.remove("disabled"); warn.classList.add("hidden"); initCustomCanvas('pose'); requestAnimationFrame(() => drawCustomEditor('pose')); }
    } else { wrap.classList.add("hidden"); warn.classList.add("hidden"); }
}

function setupHighResCanvas(canvasId, width, height) {
    let canvas = document.getElementById(canvasId); if(!canvas) return null;
    let ctx = canvas.getContext("2d"); let dpr = window.devicePixelRatio || 1;
    canvas.width = width * dpr; canvas.height = height * dpr;
    canvas.style.width = width + "px"; canvas.style.height = height + "px";
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); return { canvas, ctx, w: width, h: height };
}

function drawPill(ctx, text, x, y, bgColor, color) {
    ctx.font = "600 11px 'Be Vietnam Pro', sans-serif"; let tw = ctx.measureText(text).width;
    ctx.fillStyle = bgColor; ctx.beginPath(); ctx.roundRect(x - tw/2 - 7, y - 10, tw + 14, 20, 10); ctx.fill();
    ctx.fillStyle = color; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText(text, x, y + 1);
}

function renderStaticCurve(canvasId, curveType, tab) {
    let res = setupHighResCanvas(canvasId, 530, 110); if(!res) return;
    let { ctx, w, h } = res; let padX = 30, padY = 15; let usableW = w - padX * 2; let usableH = h - padY * 2; let midY = h / 2;
    ctx.clearRect(0, 0, w, h);
    
    let speeds = []; let dx = 0.01;
    for(let i=0; i<=100; i++) { let x = i/100; let y1 = getPacingCurve(x, curveType, tab); let y2 = getPacingCurve(x + dx, curveType, tab); speeds.push((y2 - y1) / dx); }
    
    ctx.beginPath(); ctx.moveTo(padX, midY); ctx.lineTo(w - padX, midY);
    ctx.strokeStyle = "rgba(255, 204, 102, 0.4)"; ctx.setLineDash([4, 4]); ctx.lineWidth = 1.5; ctx.stroke(); ctx.setLineDash([]);
    
    ctx.beginPath();
    for(let i=0; i<=100; i++) {
        let x = i/100; let speed = speeds[i]; let yPos = midY - (speed - 1) * (usableH / 3); 
        yPos = Math.max(padY, Math.min(h - padY, yPos));
        if(i===0) ctx.moveTo(padX + x * usableW, yPos); else ctx.lineTo(padX + x * usableW, yPos);
    }
    ctx.strokeStyle = "#ffcc66"; ctx.lineWidth = 3; ctx.lineCap = "round"; ctx.lineJoin = "round"; ctx.stroke();
    
    ctx.beginPath(); ctx.moveTo(padX - 10, h - padY); ctx.lineTo(w - padX + 10, h - padY);
    ctx.strokeStyle = "#1e3a5f"; ctx.lineWidth = 2.5; ctx.stroke();
}

function renderGraph(canvasId, mainKeys, subKeys, minF, maxF, requiredWidth) {
    let padYBottom = 45; 
    let res = setupHighResCanvas(canvasId, requiredWidth, 90 + padYBottom); if(!res) return;
    let { ctx, w, h } = res; let padX = 30, padY = 25; let usableW = w - padX * 2; let usableH = h - padYBottom - padY;
    let range = maxF - minF; if(range <= 0) range = 1;

    ctx.beginPath();
    mainKeys.forEach((key, index) => {
        let x = padX + ((key - minF) / range) * usableW; let y = h - padYBottom - (index / (mainKeys.length - 1)) * usableH;
        if(index === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    });
    ctx.strokeStyle = "#00ccff"; ctx.lineWidth = 3; ctx.lineCap = "round"; ctx.lineJoin = "round"; ctx.stroke();

    ctx.beginPath(); ctx.moveTo(padX - 10, h - padYBottom); ctx.lineTo(w - padX + 10, h - padYBottom);
    ctx.strokeStyle = "#1e3a5f"; ctx.lineWidth = 2.5; ctx.stroke();

    if (subKeys && subKeys.length > 0) {
        subKeys.forEach((key) => {
            let x = padX + ((key - minF) / range) * usableW;
            ctx.beginPath(); ctx.arc(x, h - padYBottom, 4, 0, Math.PI*2); ctx.fillStyle = "#00ccff"; ctx.fill();
            drawPill(ctx, key, x, h - padYBottom - 18, "rgba(0, 204, 255, 0.15)", "#00ccff");
        });
    }

    let lastTextX = -999; let staggerLevel = 0;
    mainKeys.forEach((key, index) => {
        let x = padX + ((key - minF) / range) * usableW; let y = h - padYBottom - (index / (mainKeys.length - 1)) * usableH;
        
        ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x, h - padYBottom);
        ctx.strokeStyle = "rgba(0, 204, 255, 0.3)"; ctx.lineWidth = 1.5; ctx.stroke();

        ctx.beginPath(); ctx.arc(x, y, 4, 0, Math.PI*2); ctx.fillStyle = "#fff"; ctx.fill();
        ctx.beginPath(); ctx.arc(x, h - padYBottom, 5, 0, Math.PI*2); ctx.fillStyle = "#ffcc66"; ctx.fill();

        if (x - lastTextX < 32) { staggerLevel = (staggerLevel + 1) % 3; } else { staggerLevel = 0; }
        lastTextX = x; let textY = h - padYBottom + 12 + (staggerLevel * 14);
        drawPill(ctx, key, x, textY, "rgba(255, 204, 102, 0.15)", "#ffcc66");
    });
}

function switchTab(tab){
    ["convertMode", "animeMode", "poseMode", "renderMode"].forEach(id => document.getElementById(id).classList.add("hidden"));
    ["tabConvert", "tabAnime", "tabPose", "tabRender"].forEach(id => document.getElementById(id).classList.remove("active"));
    document.getElementById(tab + "Mode" + (tab==="convert"?"":"")).classList.remove("hidden");
    if(tab==="convert") document.getElementById("convertMode").classList.remove("hidden");
    document.getElementById("tab" + tab.charAt(0).toUpperCase() + tab.slice(1)).classList.add("active");
    if(tab === "convert") updateConvert(); if(tab === "anime") { toggleAnimeCustom(); updateAnime(); }
    if(tab === "pose") { togglePoseCustom(); updatePoseEst(); } if(tab === "render") updateRender();
    updateAllCustomSelects();
}

function setField(id, val) { document.getElementById(id).value = val; }

function updateConvert(){
    let mode = document.getElementById("mode").value; let fps = parseFloat(document.getElementById("fps").value);
    let val = parseFloat(document.getElementById("inputValue").value); let tUnit = document.getElementById("timeUnit");
    let isTime2Frame = (mode === "t2f");
    tUnit.classList.toggle("hidden", !isTime2Frame);
    if (tUnit.parentNode && tUnit.parentNode.classList.contains("custom-select-wrapper")) tUnit.parentNode.classList.toggle("hidden", !isTime2Frame);
    if(isNaN(val) || isNaN(fps) || fps <= 0 || val < 0) { document.getElementById("convertOutput").innerHTML = "‚Äî"; return; }
    if(mode === "f2t"){
        let totalSec = val / fps; let mainStr = totalSec.toFixed(3) + " " + i18n[currentLang].dynSec;
        let h = Math.floor(totalSec / 3600), m = Math.floor((totalSec % 3600) / 60), s = parseFloat((totalSec % 60).toFixed(3));
        let subStr = (h > 0 || m > 0) ? `<span class="sub-result">‚âà ${h>0?h+"h ":""}${m}m ${s}s</span>` : "";
        document.getElementById("convertOutput").innerHTML = mainStr + subStr;
    } else {
        let frames = Math.round(val * parseFloat(tUnit.value) * fps);
        document.getElementById("convertOutput").innerHTML = frames + " " + i18n[currentLang].dynFrames;
    }
}

function toggleAnimePoseInput() { 
    let isStatic = document.getElementById("focusState").value === "static";
    document.getElementById("poseRow").classList.toggle("hidden", isStatic);
    document.getElementById("rowCorePacingA").classList.toggle("hidden", isStatic);
    document.getElementById("rowCurveTypeA").classList.toggle("hidden", isStatic);
    document.getElementById("rowLogicA").classList.toggle("hidden", isStatic);
}

function updateAnime() {
    let style = parseInt(document.getElementById("animStyle").value); let fps = parseFloat(document.getElementById("fpsAnime").value) || 24;
    let curve = document.getElementById("curveTypeAnime").value; let poses = parseInt(document.getElementById("poseCount").value) || 1;
    let logic = document.getElementById("calcLogic").value; let sf = parseInt(document.getElementById("startFrame").value) || 1;
    let ef = parseInt(document.getElementById("endFrame").value) || 100;
    if(sf > ef) { let t = sf; sf = ef; ef = t; }

    let totalF = ef - sf + 1; let t = i18n[currentLang];
    let out = `T·ªïng: <span style="color:white">${totalF}</span> frames<br>`;
    
    let isShortage = false; 
    if (totalF < style * 2 && document.getElementById("focusState").value === "dynamic") {
        isShortage = true;
    }

    let isTooLong = (totalF / fps) > 25;
    let isCustomValid = !(curve === 'custom' && (logic !== 'strict' || (totalF/fps) < 3));
    
    if(document.getElementById("focusState").value === "dynamic" && !isCustomValid) { 
        document.getElementById("animeOutput").innerHTML = out; 
        return; 
    }

    let keys = []; let isClamped = false; let clampedTo = 0;

    if (document.getElementById("focusState").value === "dynamic") {
        if(poses === 1) keys.push(sf);
        else {
            for(let i=0; i<poses; i++) {
                let x = i/(poses-1); let p = sf + getPacingCurve(x, curve, 'anime') * (totalF - 1);
                if(logic === "random" && i>0 && i<poses-1 && curve !== 'custom') {
                    let prevX = (i-1)/(poses-1); let nextX = (i+1)/(poses-1);
                    let prevP = sf + getPacingCurve(prevX, curve, 'anime') * (totalF - 1);
                    let nextP = sf + getPacingCurve(nextX, curve, 'anime') * (totalF - 1);
                    let maxJitter = Math.min(p - prevP, nextP - p) * 0.4;
                    p += (Math.random() * maxJitter * 2) - maxJitter; 
                }
                let rawSnap = sf + Math.round((p - sf)/style) * style;
                keys.push(Math.max(sf, Math.min(ef, rawSnap)));
            }
            keys = [...new Set(keys)].sort((a,b)=>a-b);
            let lastKey = keys[keys.length - 1];
            if (keys.length > 0 && (lastKey - sf) % style !== 0) { isClamped = true; clampedTo = lastKey; }
        }
        
        out += `<div class="box-result"><b>${t.dynKeysSugg}:</b><br>${keys.join(" ‚ûî ")}</div>`;
        
        if (isClamped || isShortage) {
            out += `<div class="warning" style="text-align:left; margin-top: 15px;">${t.dynClampWarn1}<b>${clampedTo || keys[keys.length-1]}</b>${t.dynClampWarn2}<b>${style}</b>${t.dynClampWarn3}</div>`;
        }
        
        if (isTooLong) {
            out += `<div class="warning" style="text-align:left; margin-top: 15px; color:#ff6b6b; border-color:#ff6b6b;">${t.dynGraphLimitWarn}</div>`;
        } else {
            out += `
            <div class="graph-title" style="margin-top: 25px; margin-bottom: 8px;"><span>${t.lblVisualGraph}</span><span class="tooltip" data-tip="${t.tipVisualGraph}">?</span></div>
            <div class="static-graph-wrapper"><canvas id="animeStaticGraph" class="graph-canvas"></canvas></div>
            <div class="graph-title" style="margin-top: 25px; margin-bottom: 8px;"><span>${t.lblDataGraph}</span><span class="tooltip" data-tip="${t.tipDataGraph}">?</span></div>
            <div class="graph-wrapper"><canvas id="animeGraph" class="graph-canvas"></canvas></div>
            <div class="graph-legend-box"><span style="color:#ffcc66">‚óè</span><span data-i18n="legendMainKey">${t.legendMainKey}</span></div>`;
        }
    } else { 
        out += `<div class="box-result">
            <b style="color:#ffcc66;">Tr·∫°ng th√°i Tƒ©nh (Static)</b><br>
            C·∫ßn v·∫Ω <b>1 Pose duy nh·∫•t</b> (ƒë·∫∑t t·∫°i frame ${sf}) v√† gi·ªØ xuy√™n su·ªët ${totalF} frames.
        </div>`; 
    }
    
    document.getElementById("animeOutput").innerHTML = out;
    
    if (document.getElementById("focusState").value === "dynamic" && !isTooLong) {
        let requiredWidth = Math.max(530, keys.length * 40);
        renderStaticCurve("animeStaticGraph", curve, 'anime'); renderGraph("animeGraph", keys, [], sf, ef, requiredWidth);
    }
}

function updateJerkHint() {
    let jerkType = document.getElementById("jerkToggle").value; let hintEl = document.getElementById("jerkHint");
    if(jerkType === "frame") {
        let style = parseInt(document.getElementById("animStylePose").value) || 2; let fps = parseFloat(document.getElementById("fpsPose").value) || 24;
        let min = style * 2; let max = Math.round((fps / 24) * 6) * style; if(max < min) max = min + style;
        hintEl.innerText = `${i18n[currentLang].dynHintFrames}${min} - ${max} frames`; hintEl.classList.remove("hidden");
    } else { hintEl.classList.add("hidden"); }
}

function togglePoseSettings() {
    let mode = document.getElementById("poseCalcMode").value; document.getElementById("rowPoseSeconds").classList.toggle("hidden", mode !== "seconds");
    let sub = document.getElementById("subPoseToggle").value; document.getElementById("rowSubPoseLogic").classList.toggle("hidden", sub !== "yes");
    if(sub === "yes") { document.getElementById("rowJerkiness").classList.add("hidden"); document.getElementById("jerkToggle").value = "no";
    } else { document.getElementById("rowJerkiness").classList.remove("hidden"); }
    let jerkType = document.getElementById("jerkToggle").value; let inputBlock = document.getElementById("jerkInputBlock");
    if(jerkType === "no") { inputBlock.classList.add("hidden"); } else {
        inputBlock.classList.remove("hidden"); let jInput = document.getElementById("jerkValue");
        if(jerkType === "sec") { jInput.step = "0.1"; if(jInput.value > 2) jInput.value = 0.2; } else { jInput.step = "1"; if(jInput.value < 1) jInput.value = 4; }
        updateJerkHint();
    }
    if(document.getElementById("jerkToggle").updateCustomUI) document.getElementById("jerkToggle").updateCustomUI();
}

function togglePoseActions() {
    let type = document.getElementById("focusTypePose").value;
    let charWrap = document.getElementById("focusActionChar").previousElementSibling; let objWrap = document.getElementById("focusActionObj").previousElementSibling;
    if(type === "char") {
        document.getElementById("focusActionObj").classList.add("hidden"); if(objWrap) objWrap.parentNode.style.display = "none";
        document.getElementById("focusActionChar").classList.remove("hidden"); if(charWrap) charWrap.parentNode.style.display = "block";
    } else {
        document.getElementById("focusActionChar").classList.add("hidden"); if(charWrap) charWrap.parentNode.style.display = "none";
        document.getElementById("focusActionObj").classList.remove("hidden"); if(objWrap) objWrap.parentNode.style.display = "block";
    }
}

function updatePoseEst() {
    let mode = document.getElementById("poseCalcMode").value; let sec = parseFloat(document.getElementById("poseSeconds").value) || 1;
    let fps = parseFloat(document.getElementById("fpsPose").value) || 24; let style = parseInt(document.getElementById("animStylePose").value) || 2;
    let pacing = document.getElementById("corePacingPose").value; let curve = document.getElementById("curveTypePose").value;
    let action = document.getElementById("focusTypePose").value === "char" ? document.getElementById("focusActionChar").value : document.getElementById("focusActionObj").value;
    let useSub = document.getElementById("subPoseToggle").value === "yes"; let subRule = document.getElementById("subPoseLogic").value;
    let jerkType = document.getElementById("jerkToggle").value; let jerkVal = parseFloat(document.getElementById("jerkValue").value) || 0;

    let totalSec = mode === "seconds" ? sec : (Math.random() * 3.5 + 1.0); 
    let totalFrames = Math.round(totalSec * fps);
    let t = i18n[currentLang];
    
    let isShortage = false;
    if(totalFrames < style * 2) { isShortage = true; }

    let isTooLong = totalSec > 25;
    let isCustomValid = !(curve === 'custom' && (mode !== 'seconds' || sec < 3));
    if(!isCustomValid) { document.getElementById("poseOutput").innerHTML = ""; return; }

    let baseDensity = 1.0;
    if(pacing==="superslow") baseDensity = 0.2; else if(pacing==="slowmo") baseDensity = 0.4; else if(pacing==="slow") baseDensity = 0.6;
    else if(pacing==="fast") baseDensity = 1.5; else if(pacing==="superfast") baseDensity = 2.0; else if(pacing==="timesplash") baseDensity = 1.2;
    if(["fight","fly","break","run"].includes(action)) baseDensity *= 1.4; if(["talk","scale"].includes(action)) baseDensity *= 0.6;

    let totalDrawings = totalFrames / style; let mainPoseCount = Math.max(2, Math.round((totalDrawings * 0.2) * baseDensity));
    if(mode === "random" && Math.random() > 0.4 && curve !== 'custom') mainPoseCount += Math.floor(Math.random()*3);

    let keys = []; let isClamped = false; let clampedTo = 0;
    for(let i=0; i<mainPoseCount; i++) {
        let x = i/(mainPoseCount-1 || 1); let p = 1 + getPacingCurve(x, curve, 'pose') * (totalFrames - 1);
        let rawSnap = 1 + Math.round((p - 1)/style) * style;
        keys.push(Math.max(1, Math.min(totalFrames, rawSnap)));
    }
    keys = [...new Set(keys)].sort((a,b)=>a-b);
    let lastKey = keys[keys.length - 1];
    if (keys.length > 0 && (lastKey - 1) % style !== 0) { isClamped = true; clampedTo = lastKey; }

    let out = `‚âà ${totalSec.toFixed(2)} ${t.dynSec} | ${totalFrames} ${t.dynFrames}<br>`;
    out += `<div class="sub-result">${t.dynEstPoses}: ${keys.length} (KFs: ${keys.join(", ")})</div>`;

    let boxHtml = ""; let subKeysList = [];
    if(useSub) {
        boxHtml += `<b>${t.dynSubPose}:</b><br>`;
        for(let i=0; i<keys.length-1; i++) {
            let k1 = keys[i], k2 = keys[i+1]; let subCount = subRule === "random" ? Math.floor(Math.random()*3)+1 : parseInt(subRule);
            let validSlots = []; for (let s = k1 + style; s < k2; s += style) validSlots.push(s);
            if (validSlots.length > 0) {
                let subs = []; let stepRatio = validSlots.length / subCount;
                for(let j=0; j<subCount; j++) {
                    let idx = Math.floor((j + 0.5) * stepRatio);
                    if(idx < validSlots.length && !subs.includes(validSlots[idx])) { subs.push(validSlots[idx]); subKeysList.push(validSlots[idx]); }
                }
                if(subs.length) boxHtml += `‚Ä¢ L√≥t gi·ªØa [${k1}] v√† [${k2}]: ${subs.join(", ")}<br>`;
            }
        }
    }
    if(jerkType !== "no" && !useSub && jerkVal > 0) {
        boxHtml += `<hr style="border-color:#1e3a5f; margin:10px 0;"><b>${t.dynHold}:</b><br>`;
        let unitText = jerkType === "sec" ? t.dynSec : t.dynFrames; let actualJerkVal = jerkVal; let isCappedHold = false;
        if (jerkType === "sec") { let maxSec = totalSec * 0.4; if (actualJerkVal > maxSec) { actualJerkVal = maxSec; isCappedHold = true; } } 
        else { let maxFrames = Math.floor(totalFrames * 0.4); if (maxFrames < 1) maxFrames = 1; if (actualJerkVal > maxFrames) { actualJerkVal = maxFrames; isCappedHold = true; } }
        actualJerkVal = jerkType === "sec" ? actualJerkVal.toFixed(2) : actualJerkVal;
        boxHtml += `${t.dynHoldMsg1} <b>${actualJerkVal}</b> ${unitText} ${t.dynHoldMsg2}`;
        if (isCappedHold) boxHtml += `<br><span style="color:#ffcc66; font-size: 12px;">(ƒê√£ gi·∫£m xu·ªëng t·ªëi ƒëa 40% c·∫£nh ƒë·ªÉ gi·ªØ nh·ªãp)</span>`;
    }

    if(boxHtml !== "") out += `<div class="box-result">${boxHtml}</div>`;
    if(isClamped || isShortage) out += `<div class="warning" style="text-align:left; margin-top: 15px;">${t.dynClampWarn1}<b>${clampedTo || keys[keys.length-1]}</b>${t.dynClampWarn2}<b>${style}</b>${t.dynClampWarn3}</div>`;

    if (isTooLong) {
        out += `<div class="warning" style="text-align:left; margin-top: 15px; color:#ff6b6b; border-color:#ff6b6b;">${t.dynGraphLimitWarn}</div>`;
    } else {
        out += `
        <div class="graph-title" style="margin-top: 25px; margin-bottom: 8px;"><span>${t.lblVisualGraph}</span><span class="tooltip" data-tip="${t.tipVisualGraph}">?</span></div>
        <div class="static-graph-wrapper"><canvas id="poseStaticGraph" class="graph-canvas"></canvas></div>
        <div class="graph-title" style="margin-top: 25px; margin-bottom: 8px;"><span>${t.lblDataGraph}</span><span class="tooltip" data-tip="${t.tipDataGraph}">?</span></div>
        <div class="graph-wrapper"><canvas id="poseGraph" class="graph-canvas"></canvas></div>
        <div class="graph-legend-box">
            <span style="color:#ffcc66">‚óè</span><span data-i18n="legendMainKey">${t.legendMainKey}</span>
            <span style="color:#00ccff; margin-left:15px;">‚óè</span><span data-i18n="legendSubKey">${t.legendSubKey}</span>
        </div>`;
    }
    
    document.getElementById("poseOutput").innerHTML = out;
    if(!isTooLong) {
        let allKeys = keys.concat(subKeysList); let requiredWidth = Math.max(530, allKeys.length * 40);
        renderStaticCurve("poseStaticGraph", curve, 'pose'); renderGraph("poseGraph", keys, subKeysList, 1, totalFrames, requiredWidth);
    }
}

function updateRender(){
    let frames = parseFloat(document.getElementById("totalFrames").value); let pFrame = parseFloat(document.getElementById("renderPerFrame").value);
    if(isNaN(frames) || isNaN(pFrame) || frames < 0 || pFrame < 0) { document.getElementById("renderOutput").innerText = "‚Äî"; return; }
    let tot = frames * pFrame; let d = Math.floor(tot / 86400), h = Math.floor((tot % 86400) / 3600), m = Math.floor((tot % 3600) / 60), s = Math.floor(tot % 60);
    let str = (d > 0 ? d + (currentLang==="vi"?" ng√†y ":"d ") : "") + `${h}h ${m}m ${s}s`; document.getElementById("renderOutput").innerText = str;
}

function changeLang(lang) {
    currentLang = lang; let t = i18n[lang];
    document.querySelectorAll('[data-i18n]').forEach(el => { el.innerText = t[el.getAttribute('data-i18n')]; });
    for (let id in t) {
        let el = document.getElementById(id);
        if (el) {
            if (el.classList.contains("tooltip")) { el.dataset.tip = t[id]; } 
            else if(el.tagName === "INPUT" && el.hasAttribute("data-i18n-ph")) { let pKey = el.getAttribute("data-i18n-ph"); if(t[pKey]) el.placeholder = t[pKey]; } 
            else { el.innerText = t[id]; }
        }
    }
    let sF = document.getElementById("startFrame"); if(sF) sF.placeholder = t.phStartFrame;
    let eF = document.getElementById("endFrame"); if(eF) eF.placeholder = t.phEndFrame;
    updateConvert(); updateAnime(); updatePoseEst(); updateRender(); updateAllCustomSelects(); updateJerkHint();
}

function initCustomSelects() {
    document.querySelectorAll("select").forEach(sel => {
        if(sel.nextElementSibling && sel.nextElementSibling.classList.contains("custom-select-options")) return;
        const wrap = document.createElement("div"); wrap.className = "custom-select-wrapper"; sel.parentNode.insertBefore(wrap, sel); wrap.appendChild(sel);
        const trig = document.createElement("div"); trig.className = "custom-select-trigger"; const opts = document.createElement("div"); opts.className = "custom-select-options"; wrap.appendChild(trig); wrap.appendChild(opts);
        function updateUI() { if(sel.selectedIndex >= 0) trig.innerHTML = `<span>${sel.options[sel.selectedIndex].text}</span><div class="arrow"></div>`; }
        function buildOpts() {
            opts.innerHTML = "";
            Array.from(sel.options).forEach((o, i) => {
                const od = document.createElement("div"); od.className = "custom-select-option";
                if(i === sel.selectedIndex) od.classList.add("selected"); od.innerText = o.text;
                od.addEventListener("click", (e) => { e.stopPropagation(); sel.selectedIndex = i; sel.dispatchEvent(new Event("change")); updateUI(); opts.classList.remove("show"); trig.classList.remove("active"); });
                opts.appendChild(od);
            });
        }
        trig.addEventListener("click", (e) => {
            e.stopPropagation(); const isS = opts.classList.contains("show");
            document.querySelectorAll(".custom-select-options").forEach(el => el.classList.remove("show"));
            document.querySelectorAll(".custom-select-trigger").forEach(el => el.classList.remove("active"));
            if(!isS) { buildOpts(); opts.classList.add("show"); trig.classList.add("active"); }
        });
        updateUI(); sel.style.display = "none"; sel.updateCustomUI = updateUI;
    });
    document.addEventListener("click", () => {
        document.querySelectorAll(".custom-select-options").forEach(el => el.classList.remove("show"));
        document.querySelectorAll(".custom-select-trigger").forEach(el => el.classList.remove("active"));
    });
}
function updateAllCustomSelects() { document.querySelectorAll("select").forEach(s => { if(s.updateCustomUI) s.updateCustomUI(); }); }

window.addEventListener("DOMContentLoaded", () => { 
    initCustomSelects(); changeLang('vi'); togglePoseActions(); togglePoseSettings(); toggleAnimePoseInput();
});
</script>
</body>
</html>
