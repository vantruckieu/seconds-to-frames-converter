<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title id="title">Timing & Render Tool</title>

<style>
@import url('https://fonts.googleapis.com/css2?family=Be+Vietnam+Pro:wght@400;500;600;700&display=swap');

body {
    color-scheme: dark; 
    background: radial-gradient(circle at 20% 20%, #0f1c2e, #050b18 70%);
    font-family: 'Google Sans', 'Be Vietnam Pro', 'Segoe UI', sans-serif;
    color: #e6f3ff;
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 0;
    padding: 40px 20px 80px 20px;
    min-height: 100vh;
    box-sizing: border-box;
}

h1 { margin: 0 0 10px 0; font-size: 28px; text-align: center; color: #00ccff; text-shadow: 0 0 20px rgba(0,200,255,0.6); }
.intro { text-align: center; max-width: 600px; margin-bottom: 30px; opacity: 0.8; line-height: 1.5; font-size: 15px; }

.container {
    background: linear-gradient(145deg, #0e1624, #111c2f);
    padding: 35px; border-radius: 20px; width: 100%; max-width: 600px; 
    box-shadow: 0 0 40px rgba(0,140,255,0.25), inset 0 0 60px rgba(0,80,160,0.15);
    border: 1px solid rgba(0,180,255,0.2); box-sizing: border-box;
}

.tabs { display: flex; gap: 8px; margin-bottom: 25px; flex-wrap: wrap; }
.tabs button {
    flex: 1; min-width: 120px; padding: 12px 5px; min-height: 44px;
    background: #0c1626; border: 1px solid #1b3555; border-radius: 10px;
    color: #7fbfff; cursor: pointer; transition: 0.3s; font-weight: 500; font-family: inherit; font-size: 14px;
}
.tabs button:hover { background: #11233d; box-shadow: 0 0 12px rgba(0,170,255,0.4); }
.tabs button.active { background: linear-gradient(90deg,#0066ff,#00ccff); color: white; border-color: #00ccff; box-shadow: 0 0 20px rgba(0,200,255,0.6); }

.tab-desc { font-size: 13px; color: #9ed8ff; background: rgba(0, 150, 255, 0.08); border-left: 3px solid #00ccff; padding: 12px 15px; margin-bottom: 22px; border-radius: 0 8px 8px 0; line-height: 1.5; }
.row { margin-bottom: 20px; transition: all 0.3s ease; }
label { display: flex; align-items: center; margin-bottom: 8px; font-size: 14px; opacity: 0.85; color: #9ed8ff; }

input[type="number"] {
    width: 100%; padding: 14px; font-size: 16px; min-height: 44px; font-family: inherit;
    background: #0a1422; border: 1px solid #1e3a5f; border-radius: 10px; color: #e6f3ff; transition: 0.3s; box-sizing: border-box;
}
input[type="number"]:focus { outline: none; border-color: #00ccff; box-shadow: 0 0 12px rgba(0,200,255,0.5); }

/* CUSTOM DROPDOWN */
.custom-select-wrapper { position: relative; width: 100%; }
.custom-select-wrapper:has(select.hidden) { display: none !important; }
.input-group .custom-select-wrapper { flex: 1; }
.custom-select-trigger {
    width: 100%; padding: 14px; font-size: 15px; font-family: inherit; min-height: 44px;
    background: #0a1422; border: 1px solid #1e3a5f; border-radius: 10px; color: #e6f3ff; cursor: pointer; display: flex; justify-content: space-between; align-items: center; transition: 0.3s; box-sizing: border-box; user-select: none;
}
.custom-select-trigger:hover, .custom-select-trigger.active { border-color: #00ccff; box-shadow: 0 0 12px rgba(0,200,255,0.5); }
.custom-select-trigger .arrow {
    width: 16px; height: 16px; background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%239ed8ff' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e"); background-size: contain; background-repeat: no-repeat; background-position: center; transition: transform 0.3s;
}
.custom-select-trigger.active .arrow { transform: rotate(180deg); }
.custom-select-options {
    position: absolute; top: calc(100% + 5px); left: 0; right: 0; background: #0a1422;
    border: 1px solid #1e3a5f; border-radius: 10px; box-shadow: 0 5px 20px rgba(0,0,0,0.6); z-index: 99; opacity: 0; visibility: hidden; transform: translateY(-10px); transition: all 0.2s ease-out; overflow-y: auto; max-height: 250px;
}
.custom-select-options.show { opacity: 1; visibility: visible; transform: translateY(0); }
.custom-select-option { padding: 14px; font-size: 14px; cursor: pointer; transition: 0.2s; color: #e6f3ff; border-bottom: 1px solid rgba(30, 58, 95, 0.4); }
.custom-select-option:last-child { border-bottom: none; }
.custom-select-option:hover, .custom-select-option.selected { background: #11233d; color: #00ccff; }

.input-group { display: flex; gap: 10px; flex-wrap: wrap; }
.input-group input[type="number"], .input-group .custom-select-wrapper { flex: 1; min-width: 140px; }
.fps-presets { display: flex; gap: 8px; margin-top: 10px; }
.fps-presets button { flex: 1; padding: 10px 6px; background: #0e1c2f; border: 1px solid #1f4068; border-radius: 8px; color: #66ccff; cursor: pointer; font-size: 14px; transition: 0.2s; min-height: 40px; }
.fps-presets button:hover { background: #133a66; box-shadow: 0 0 8px rgba(0,200,255,0.6); }

.result { margin-top: 25px; font-size: 24px; font-weight: bold; color: #00ccff; text-align: center; text-shadow: 0 0 15px rgba(0,200,255,0.6); }
.sub-result { display: block; font-size: 14px; font-weight: normal; color: #9ed8ff; margin-top: 8px; opacity: 0.9; line-height: 1.5; }
.box-result { font-size: 14px; color: #cceeff; background: rgba(0, 102, 255, 0.1); border: 1px dashed #0066ff; padding: 15px; border-radius: 10px; margin-top: 15px; text-align: left; line-height: 1.6;}

.tooltip {
    display: inline-flex; align-items: center; justify-content: center; width: 18px; height: 18px; background: rgba(0, 204, 255, 0.1); border: 1px solid #00ccff; border-radius: 50%; color: #00ccff; font-size: 12px; font-weight: bold; cursor: help; position: relative; margin-left: 8px; transition: 0.3s;
}
.tooltip:hover { background: #00ccff; color: #0a1422; box-shadow: 0 0 10px rgba(0, 204, 255, 0.6); }
.tooltip:hover::after {
    content: attr(data-tip); position: absolute; bottom: 150%; left: 50%; transform: translateX(-50%); background: #02111f; padding: 12px 14px; font-size: 13px; font-weight: normal; border-radius: 8px; width: 250px; color: #cceeff; box-shadow: 0 4px 15px rgba(0,170,255,0.6); border: 1px solid rgba(0, 204, 255, 0.4); z-index: 9999; text-align: left; white-space: pre-wrap; line-height: 1.5; word-wrap: break-word;
}
.warning { margin-top: 15px; font-size: 14px; color: #ffcc66; background: rgba(255, 204, 102, 0.1); padding: 15px; border-radius: 10px; border: 1px solid rgba(255, 204, 102, 0.3); line-height: 1.5;}
.hidden { display: none !important; }

/* Graph Styling */
.graph-title-block { display: flex; justify-content: space-between; align-items: center; margin-top: 25px; margin-bottom: 8px; }
.graph-title { font-size: 13px; font-weight: 600; color: #9ed8ff; display: flex; align-items: center; justify-content: center; gap: 6px; }

.static-graph-wrapper { background: rgba(10, 20, 34, 0.4); border-radius: 12px; border: 1px dashed #1e3a5f; width: 100%; margin-top: 5px; box-sizing: border-box; display: flex; justify-content: center; padding: 15px 0; overflow: hidden; }
.graph-wrapper { margin-top: 5px; background: rgba(10, 20, 34, 0.6); border-radius: 12px; border: 1px solid #1e3a5f; width: 100%; overflow-x: auto; box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.5); padding: 15px 0 0 0; -webkit-overflow-scrolling: touch; }
.graph-wrapper::-webkit-scrollbar { height: 8px; }
.graph-wrapper::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); border-radius: 10px; }
.graph-wrapper::-webkit-scrollbar-thumb { background: #1e3a5f; border-radius: 10px; }
.graph-wrapper::-webkit-scrollbar-thumb:hover { background: #00ccff; }
.graph-canvas { display: block; background: transparent; border: none; box-shadow: none; margin: 0 auto; }

/* Custom Curve Editor ‚Äî styled like graph-wrapper / D√≤ng th·ªùi gian */
.custom-editor {
    margin-top: 12px;
    background: rgba(10, 20, 34, 0.6);
    border-radius: 12px;
    border: 1px solid #1e3a5f;
    overflow: hidden;
    box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.5);
}
.custom-editor.disabled { opacity: 0.4; pointer-events: none; }
.custom-editor.hidden { display: none !important; }

/* Header bar inside editor ‚Äî same feel as graph-title */
.custom-editor-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 15px;
    border-bottom: 1px solid #1e3a5f;
    background: rgba(0, 102, 255, 0.05);
    flex-wrap: wrap;
    gap: 8px;
}
.custom-editor-title {
    font-size: 13px;
    font-weight: 600;
    color: #9ed8ff;
    display: flex;
    align-items: center;
    gap: 10px;
}
.custom-editor-controls {
    display: flex;
    align-items: center;
    gap: 8px;
    flex-wrap: wrap;
}

/* Fix Checkbox Alignment */
.checkbox-lbl { font-size: 12px; color: #9ed8ff; display: flex; align-items: center; gap: 5px; cursor: pointer; user-select: none; margin: 0;}
.checkbox-lbl input[type="checkbox"] { 
    appearance: none; -webkit-appearance: none;
    width: 14px; height: 14px; background: #0a1422; border: 1px solid #1e3a5f; border-radius: 3px; 
    cursor: pointer; position: relative; margin: 0; outline: none; flex-shrink: 0; transition: 0.2s;
}
.checkbox-lbl input[type="checkbox"]:checked { background: #00ccff; border-color: #00ccff; }
.checkbox-lbl input[type="checkbox"]:checked::after {
    content: ''; position: absolute; top: 1px; left: 4px;
    width: 3px; height: 6px; border: solid #050b18; border-width: 0 2px 2px 0;
    transform: rotate(45deg);
}

.editor-btn { background: #0c1626; border: 1px solid #1b3555; color: #9ed8ff; border-radius: 6px; padding: 5px 10px; cursor: pointer; font-size: 11px; transition: 0.2s; white-space: nowrap;}
.editor-btn:hover { background: #11233d; color: #00ccff; border-color:#00ccff; }
.btn-reset { color: #ffcc66; border-color: rgba(255, 204, 102, 0.4); }
.btn-reset:hover { background: rgba(255, 204, 102, 0.1); border-color: #ffcc66; color: #ffcc66; }

/* Canvas area inside editor ‚Äî scrollable like graph-wrapper */
.custom-editor-canvas-wrap {
    width: 100%;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
    padding: 10px 0 0 0;
}
.custom-editor-canvas-wrap::-webkit-scrollbar { height: 8px; }
.custom-editor-canvas-wrap::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); border-radius: 10px; }
.custom-editor-canvas-wrap::-webkit-scrollbar-thumb { background: #1e3a5f; border-radius: 10px; }
.custom-editor-canvas-wrap::-webkit-scrollbar-thumb:hover { background: #00ccff; }

.editor-canvas-inner {
    cursor: crosshair;
    touch-action: none;
    display: block;
    background: transparent;
    margin: 0 auto;
}

/* Outside Legend */
.graph-legend-box { display: flex; justify-content: center; gap: 20px; padding: 12px 0 0 0; font-size: 13px; color: #9ed8ff; }
.graph-legend-box span { display: flex; align-items: center; gap: 6px; }

footer { margin-top: 40px; font-size: 14px; color: #66ccff; opacity: 0.8; display: flex; align-items: center; justify-content: center; gap: 10px; }
footer .custom-select-wrapper { width: auto; min-width: 110px; }
footer .custom-select-trigger { padding: 8px 12px; font-size: 14px; border-radius: 6px; min-height: unset; }

.note-text { font-size: 13px; color: #66ccff; margin-top: 6px; display: block; opacity: 0.8; }

@media (max-width: 600px) {
    body { padding: 20px 10px 50px 10px; }
    .container { padding: 25px 20px; border-radius: 15px; }
    h1 { font-size: 24px; }
}
</style>
</head>

<body>

<h1 id="mainTitle">Timing & Render Tool</h1>
<div class="intro" id="introText">C√¥ng c·ª• ƒëa nƒÉng h·ªó tr·ª£ Animation Timing, T√≠nh to√°n Frame v√† Render.</div>

<div class="container">
    <div class="tabs">
        <button id="tabConvert" class="active" onclick="switchTab('convert')">Time / Frame</button>
        <button id="tabAnime" onclick="switchTab('anime')">Anime, Toon Frame</button>
        <button id="tabPose" onclick="switchTab('pose')">D·ª± t√≠nh Pose</button>
        <button id="tabRender" onclick="switchTab('render')">Render Time</button>
    </div>

    <!-- TAB: Convert -->
    <div id="convertMode">
        <div class="tab-desc" id="descConvert">Chuy·ªÉn ƒë·ªïi qua l·∫°i gi·ªØa th·ªùi l∆∞·ª£ng (Gi√¢y/Ph√∫t/Gi·ªù) v√† S·ªë khung h√¨nh (Frames) theo t·ªëc ƒë·ªô chu·∫©n.</div>
        <div class="row">
            <label><span id="lblMode">Lo·∫°i t√≠nh</span><span class="tooltip" id="tipMode" data-tip="?">?</span></label>
            <select id="mode" onchange="updateConvert()"><option id="optF2T" value="f2t">Frame ‚Üí Time</option><option id="optT2F" value="t2f">Time ‚Üí Frame</option></select>
        </div>
        <div class="row">
            <label><span id="lblFPS_conv">FPS</span><span class="tooltip" id="tipFPS_conv" data-tip="?">?</span></label>
            <input type="number" id="fps" step="0.001" value="24" min="1" oninput="updateConvert()">
            <div class="fps-presets">
                <button onclick="setField('fps', 12); updateConvert()">12</button>
                <button onclick="setField('fps', 24); updateConvert()">24</button>
                <button onclick="setField('fps', 30); updateConvert()">30</button>
                <button onclick="setField('fps', 60); updateConvert()">60</button>
            </div>
        </div>
        <div class="row">
            <label><span id="lblInput">S·ªë khung h√¨nh/th·ªùi gian</span><span class="tooltip" id="tipInput" data-tip="?">?</span></label>
            <div class="input-group">
                <input type="number" id="inputValue" min="0" oninput="updateConvert()">
                <select id="timeUnit" class="hidden" onchange="updateConvert()"><option id="optSec" value="1">Gi√¢y</option><option id="optMin" value="60">Ph√∫t</option><option id="optHour" value="3600">Gi·ªù</option></select>
            </div>
        </div>
        <div class="result" id="convertOutput">‚Äî</div>
    </div>

    <!-- TAB: Anime -->
    <div id="animeMode" class="hidden">
        <div class="tab-desc" id="descAnime">Ph√¢n b·ªï kho·∫£ng c√°ch c√°c Keyframe theo quy t·∫Øc Animation (On 1s, 2s, 3s) v√† n·ªôi suy nh·ªãp ƒë·ªô c·∫£nh.</div>
        
        <div class="row">
            <label><span id="lblFocus">T√¢m ƒëi·ªÉm & Tr·∫°ng th√°i</span><span class="tooltip" id="tipFocus" data-tip="?">?</span></label>
            <div class="input-group">
                <select id="focusTarget" onchange="updateAnime()"><option id="optFocScene" value="scene">C·∫£nh</option><option id="optFocChar" value="char">Nh√¢n v·∫≠t/V·∫≠t th·ªÉ</option></select>
                <select id="focusState" onchange="toggleAnimePoseInput(); updateAnime()"><option id="optStateStatic" value="static">Tƒ©nh</option><option id="optStateDynamic" value="dynamic" selected>ƒê·ªông</option></select>
            </div>
        </div>

        <div class="row">
            <label><span id="lblAnimStyle">Ki·ªÉu di·ªÖn ho·∫°t</span><span class="tooltip" id="tipAnimStyle" data-tip="?">?</span></label>
            <select id="animStyle" onchange="updateAnime()"><option id="optOn1s" value="1">On 1s (M∆∞·ª£t / H√†nh ƒë·ªông)</option><option id="optOn2s" value="2" selected>On 2s (Chu·∫©n Anime)</option><option id="optOn3s" value="3">On 3s (Tƒ©nh / Ch·∫≠m)</option></select>
        </div>
        
        <div class="row">
            <label><span id="lblFPS_anime">FPS g·ªëc</span><span class="tooltip" id="tipFPS_anime" data-tip="?">?</span></label>
            <input type="number" id="fpsAnime" value="24" min="1" oninput="updateAnime()">
            <div class="fps-presets">
                <button onclick="setField('fpsAnime', 12); updateAnime()">12</button>
                <button onclick="setField('fpsAnime', 24); updateAnime()">24</button>
                <button onclick="setField('fpsAnime', 30); updateAnime()">30</button>
                <button onclick="setField('fpsAnime', 60); updateAnime()">60</button>
            </div>
        </div>

        <div class="row" id="rowCorePacingA">
            <label><span id="lblCorePacingAnime">Nh·ªãp t√¢m ƒëi·ªÉm</span><span class="tooltip" id="tipCorePacingAnime" data-tip="?">?</span></label>
            <select id="corePacingAnime" onchange="updateAnime()">
                <option id="optCpSuperSlowA" value="superslow">Super Slow</option><option id="optCpSlowmoA" value="slowmo">Slow Motion</option><option id="optCpSlowA" value="slow">Ch·∫≠m</option><option id="optCpNormalA" value="normal" selected>B√¨nh th∆∞·ªùng</option><option id="optCpFastA" value="fast">Nhanh</option><option id="optCpSuperFastA" value="superfast">C·ª±c nhanh</option><option id="optCpTimeSplashA" value="timesplash">Time Splash</option>
            </select>
        </div>

        <div class="row" id="rowCurveTypeA">
            <label><span id="lblCurveTypeAnime">Lo·∫°i ƒë·ªì th·ªã (Ph√¢n b·ªï)</span><span class="tooltip" id="tipCurveTypeAnime" data-tip="?">?</span></label>
            <select id="curveTypeAnime" onchange="toggleAnimeCustom(); updateAnime()">
                <option id="optCvNoneA" value="linear">Kh√¥ng (ƒê·ªÅu)</option><option id="optCvEaseOutA" value="ease_out">ƒê·ªì th·ªã xu·ªëng (Ch·∫≠m d·∫ßn)</option><option id="optCvEaseInA" value="ease_in">ƒê·ªì th·ªã l√™n (Nhanh d·∫ßn)</option><option id="optCvClimaxA" value="climax">ƒêi·ªÉm cao tr√†o (Nhanh gi·ªØa)</option><option id="optCvLowPointA" value="low_point">ƒêi·ªÉm tr·∫ßm (Ch·∫≠m gi·ªØa)</option><option id="optCvWaveA" value="wave">S√≥ng (Nhanh ch·∫≠m xen k·∫Ω)</option><option id="optCvCustomA" value="custom">T√πy ch·ªânh (ƒê·ªì th·ªã t·ªëc ƒë·ªô)</option>
            </select>
            
            <div id="customEditorWrap_anime" class="custom-editor hidden">
                <div class="custom-editor-header">
                    <div class="custom-editor-title">
                        <span id="lblEditorA">Time Remapping</span>
                        <label class="checkbox-lbl"><input type="checkbox" id="smoothCurve_anime" checked> <span id="lblSmoothA">M∆∞·ª£t</span></label>
                        <label class="checkbox-lbl"><input type="checkbox" id="lockEnd_anime" checked> <span id="lblLockA">Kh√≥a m√∫t</span></label>
                    </div>
                    <div class="custom-editor-controls">
                        <button class="editor-btn btn-reset" onclick="resetCustomPoints('anime')" id="btnResetA">ƒê·∫∑t l·∫°i</button>
                        <button class="editor-btn" onclick="modifyCustomPoints('anime', 1)">+ ƒêi·ªÉm</button>
                        <button class="editor-btn" onclick="modifyCustomPoints('anime', -1)">‚àí ƒêi·ªÉm</button>
                    </div>
                </div>
                <div class="custom-editor-canvas-wrap">
                    <canvas id="customCanvas_anime" class="editor-canvas-inner"></canvas>
                </div>
            </div>
            <div id="warnCustomAnime" class="warning hidden" style="color:#ffcc66; border-color:#ffcc66;"></div>
        </div>
        
        <div class="row" id="poseRow">
            <label><span id="lblPose">S·ªë Pose (Keyframes ch√≠nh)</span><span class="tooltip" id="tipPose" data-tip="?">?</span></label>
            <input type="number" id="poseCount" value="5" min="1" oninput="updateAnime()">
        </div>

        <div class="row" id="rowLogicA">
            <label><span id="lblCalcLogic">Logic t√≠nh to√°n</span><span class="tooltip" id="tipCalcLogic" data-tip="?">?</span></label>
            <select id="calcLogic" onchange="toggleAnimeCustom(); updateAnime()"><option id="optLogicStrict" value="strict">To√°n h·ªçc nghi√™m ng·∫∑t</option><option id="optLogicRandom" value="random">X√°c su·∫•t ng·∫´u nhi√™n</option></select>
        </div>

        <div class="row">
            <label><span id="lblFrameRange">Frame B·∫Øt ƒë·∫ßu - K·∫øt th√∫c</span><span class="tooltip" id="tipFrameRange" data-tip="?">?</span></label>
            <div class="input-group">
                <input type="number" id="startFrame" data-i18n-ph="phStartFrame" placeholder="B·∫Øt ƒë·∫ßu (vd: 1)" oninput="updateAnime(); toggleAnimeCustom()">
                <input type="number" id="endFrame" data-i18n-ph="phEndFrame" placeholder="K·∫øt th√∫c (vd: 100)" oninput="updateAnime(); toggleAnimeCustom()">
            </div>
        </div>
        
        <div class="result" id="animeOutput">‚Äî</div>
        <div class="warning" id="warnMathModelAnime">‚ö† L∆∞u √Ω: M√¥ h√¨nh ƒë·ªì th·ªã v√† to√°n h·ªçc ch·ªâ mang t√≠nh ch·∫•t g·ª£i √Ω tham kh·∫£o.</div>
    </div>

    <!-- TAB: Pose -->
    <div id="poseMode" class="hidden">
        <div class="tab-desc" id="descPose">T·ª± ƒë·ªông ∆∞·ªõc t√≠nh s·ªë l∆∞·ª£ng Pose ch√≠nh v√† Pose ph·ª• tr·ª£ (In-betweens) ph·ª• thu·ªôc v√†o h√†nh ƒë·ªông c·ª• th·ªÉ v√† th·ªùi l∆∞·ª£ng.</div>
        <div class="row">
            <label><span id="lblPoseCalcMode">C√°ch t√≠nh to√°n</span><span class="tooltip" id="tipPoseCalcMode" data-tip="?">?</span></label>
            <select id="poseCalcMode" onchange="togglePoseSettings(); togglePoseCustom(); updatePoseEst()"><option id="optPcalcRandom" value="random">X√°c su·∫•t ng·∫´u nhi√™n</option><option id="optPcalcSeconds" value="seconds" selected>Theo s·ªë gi√¢y c·∫£nh</option></select>
        </div>
        <div class="row" id="rowPoseSeconds">
            <label><span id="lblPoseSeconds">Nh·∫≠p s·ªë gi√¢y c·∫£nh</span><span class="tooltip" id="tipPoseSeconds" data-tip="?">?</span></label>
            <input type="number" id="poseSeconds" value="4" min="0.1" step="0.1" oninput="togglePoseCustom(); updatePoseEst()">
        </div>
        <div class="row">
            <label><span id="lblFPS_pose">FPS g·ªëc</span><span class="tooltip" id="tipFPS_pose" data-tip="?">?</span></label>
            <input type="number" id="fpsPose" value="24" min="1" oninput="updatePoseEst(); updateJerkHint()">
            <div class="fps-presets">
                <button onclick="setField('fpsPose', 12); updatePoseEst(); updateJerkHint()">12</button>
                <button onclick="setField('fpsPose', 24); updatePoseEst(); updateJerkHint()">24</button>
                <button onclick="setField('fpsPose', 30); updatePoseEst(); updateJerkHint()">30</button>
                <button onclick="setField('fpsPose', 60); updatePoseEst(); updateJerkHint()">60</button>
            </div>
        </div>
        <div class="row">
            <label><span id="lblAnimStylePose">Lo·∫°i di·ªÖn ho·∫°t</span><span class="tooltip" id="tipAnimStylePose" data-tip="?">?</span></label>
            <select id="animStylePose" onchange="updatePoseEst(); updateJerkHint()"><option id="optPO1" value="1">On 1s</option><option id="optPO2" value="2" selected>On 2s</option><option id="optPO3" value="3">On 3s</option></select>
        </div>
        <div class="row">
            <label><span id="lblFocusTypePose">Lo·∫°i t√¢m ƒëi·ªÉm</span><span class="tooltip" id="tipFocusTypePose" data-tip="?">?</span></label>
            <select id="focusTypePose" onchange="togglePoseActions(); updatePoseEst()"><option id="optFocCharP" value="char">Nh√¢n v·∫≠t</option><option id="optFocObjP" value="obj">V·∫≠t th·ªÉ</option></select>
        </div>
        <div class="row">
            <label><span id="lblFocusActionPose">H√†nh ƒë·ªông c·ª• th·ªÉ</span><span class="tooltip" id="tipFocusActionPose" data-tip="?">?</span></label>
            <select id="focusActionChar" class="" onchange="updatePoseEst()"><option value="talk" id="actTalk">N√≥i chuy·ªán</option><option value="walk" id="actWalk">ƒêi b·ªô</option><option value="run" id="actRun">Ch·∫°y</option><option value="fight" id="actFight">ƒê√°nh nhau</option><option value="other" id="actOtherC">H√†nh ƒë·ªông kh√°c</option></select>
            <select id="focusActionObj" class="hidden" onchange="updatePoseEst()"><option value="fly" id="actFly">Bay</option><option value="fall" id="actFall">R∆°i</option><option value="break" id="actBreak">V·ª°/G√£y</option><option value="bounce" id="actBounce">N·∫£y l√™n/xu·ªëng</option><option value="scale" id="actScale">Ph√≥ng to/Thu nh·ªè</option><option value="other" id="actOtherO">H√†nh ƒë·ªông kh√°c</option></select>
        </div>
        <div class="row">
            <label><span id="lblCorePacingPose">Nh·ªãp t√¢m ƒëi·ªÉm</span><span class="tooltip" id="tipCorePacingPose" data-tip="?">?</span></label>
            <select id="corePacingPose" onchange="updatePoseEst()"><option id="optCpSuperSlowP" value="superslow">Super Slow</option><option id="optCpSlowmoP" value="slowmo">Slow Motion</option><option id="optCpSlowP" value="slow">Ch·∫≠m</option><option id="optCpNormalP" value="normal" selected>B√¨nh th∆∞·ªùng</option><option id="optCpFastP" value="fast">Nhanh</option><option id="optCpSuperFastP" value="superfast">C·ª±c nhanh</option><option id="optCpTimeSplashP" value="timesplash">Time Splash</option></select>
        </div>
        <div class="row">
            <label><span id="lblCurveTypePose">Lo·∫°i ƒë·ªì th·ªã</span><span class="tooltip" id="tipCurveTypePose" data-tip="?">?</span></label>
            <select id="curveTypePose" onchange="togglePoseCustom(); updatePoseEst()">
                <option id="optCvNoneP" value="linear">Kh√¥ng</option><option id="optCvEaseOutP" value="ease_out">ƒê·ªì th·ªã xu·ªëng</option><option id="optCvEaseInP" value="ease_in">ƒê·ªì th·ªã l√™n</option><option id="optCvClimaxP" value="climax">ƒêi·ªÉm cao tr√†o</option><option id="optCvLowPointP" value="low_point">ƒêi·ªÉm tr·∫ßm</option><option id="optCvWaveP" value="wave">S√≥ng (Cao/th·∫•p c·∫°nh nhau)</option><option id="optCvCustomP" value="custom">T√πy ch·ªânh (ƒê·ªì th·ªã t·ªëc ƒë·ªô)</option>
            </select>
            
            <div id="customEditorWrap_pose" class="custom-editor hidden">
                <div class="custom-editor-header">
                    <div class="custom-editor-title">
                        <span id="lblEditorP">Time Remapping</span>
                        <label class="checkbox-lbl"><input type="checkbox" id="smoothCurve_pose" checked> <span id="lblSmoothP">M∆∞·ª£t</span></label>
                        <label class="checkbox-lbl"><input type="checkbox" id="lockEnd_pose" checked> <span id="lblLockP">Kh√≥a m√∫t</span></label>
                    </div>
                    <div class="custom-editor-controls">
                        <button class="editor-btn btn-reset" onclick="resetCustomPoints('pose')" id="btnResetP">ƒê·∫∑t l·∫°i</button>
                        <button class="editor-btn" onclick="modifyCustomPoints('pose', 1)">+ ƒêi·ªÉm</button>
                        <button class="editor-btn" onclick="modifyCustomPoints('pose', -1)">‚àí ƒêi·ªÉm</button>
                    </div>
                </div>
                <div class="custom-editor-canvas-wrap">
                    <canvas id="customCanvas_pose" class="editor-canvas-inner"></canvas>
                </div>
            </div>
            <div id="warnCustomPose" class="warning hidden" style="color:#ff6b6b; border-color:#ff6b6b;"></div>
        </div>
        <div class="row">
            <label><span id="lblSubPose">Th√™m Pose ph·ª• tr·ª£ (In-betweens)</span><span class="tooltip" id="tipSubPose" data-tip="?">?</span></label>
            <select id="subPoseToggle" onchange="togglePoseSettings(); updatePoseEst()"><option id="optNo" value="no">Kh√¥ng</option><option id="optYes" value="yes">C√≥</option></select>
        </div>
        <div class="row hidden" id="rowSubPoseLogic">
            <label><span id="lblSubPoseLogic">Quy t·∫Øc Pose ph·ª• tr·ª£</span><span class="tooltip" id="tipSubPoseLogic" data-tip="?">?</span></label>
            <select id="subPoseLogic" onchange="updatePoseEst()"><option id="optSpRandom" value="random">X√°c su·∫•t ng·∫´u nhi√™n</option><option value="1">1 Pose ph·ª•</option><option value="2">2 Pose ph·ª•</option><option value="3">3 Pose ph·ª•</option><option value="4">4 Pose ph·ª•</option></select>
        </div>
        
        <div class="row" id="rowJerkiness">
            <label><span id="lblJerkiness">ƒê·ªô gi·∫≠t - kh·ª±ng (Stutter/Hold)</span><span class="tooltip" id="tipJerkiness" data-tip="?">?</span></label>
            <select id="jerkToggle" onchange="togglePoseSettings(); updatePoseEst()"><option id="optJerkNo" value="no">Kh√¥ng</option><option id="optJerkSec" value="sec">Theo Gi√¢y</option><option id="optJerkFrame" value="frame">Theo Frame</option></select>
            <div id="jerkInputBlock" class="hidden" style="margin-top: 10px;">
                <input type="number" id="jerkValue" value="2" min="0" step="0.1" oninput="updatePoseEst()">
                <span id="jerkHint" class="note-text hidden"></span>
            </div>
        </div>
        <div class="result" id="poseOutput">‚Äî</div>
        <div class="warning" id="warnMathModelPose">‚ö† L∆∞u √Ω: H·ªá th·ªëng ch·ªâ t√≠nh to√°n g·ª£i √Ω v·ªã tr√≠ l√Ω thuy·∫øt, m·∫≠t ƒë·ªô th·ª±c t·∫ø ph·ª• thu·ªôc b·∫£n v·∫Ω.</div>
    </div>

    <!-- TAB: Render -->
    <div id="renderMode" class="hidden">
        <div class="tab-desc" id="descRender">∆Ø·ªõc t√≠nh t·ªïng th·ªùi gian xu·∫•t file (Render) c·ªßa to√†n b·ªô d·ª± √°n d·ª±a tr√™n th·ªùi gian ch·∫°y 1 khung h√¨nh.</div>
        <div class="row">
            <label><span id="lblTotalFrames">T·ªïng s·ªë frame</span><span class="tooltip" id="tipTotalFrames" data-tip="?">?</span></label>
            <input type="number" id="totalFrames" min="0" oninput="updateRender()">
        </div>
        <div class="row">
            <label><span id="lblRenderPerFrame">Th·ªùi gian render 1 frame (gi√¢y)</span><span class="tooltip" id="tipRenderPerFrame" data-tip="?">?</span></label>
            <input type="number" id="renderPerFrame" step="0.01" min="0" oninput="updateRender()">
        </div>
        <div class="result" id="renderOutput">‚Äî</div>
        <div class="warning" id="warningTextRender">‚ö† Ch·ªâ d√πng ƒë·ªÉ tham kh·∫£o. M·∫≠t ƒë·ªô chi ti·∫øt c·∫£nh th·ª±c t·∫ø s·∫Ω l√†m ƒë·ªïi th·ªùi gian.</div>
    </div>
</div>

<footer>
    <span id="lblLanguage">Ng√¥n ng·ªØ:</span>
    <select onchange="changeLang(this.value)"><option value="vi">üáªüá≥ VI</option><option value="en">üá¨üáß EN</option></select>
</footer>

<script>
// Canvas Polyfill
if (!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
        if (w < 2 * r) r = w / 2; if (h < 2 * r) r = h / 2;
        this.beginPath(); this.moveTo(x + r, y); this.arcTo(x + w, y, x + w, y + h, r);
        this.arcTo(x + w, y + h, x, y + h, r); this.arcTo(x, y + h, x, y, r); this.arcTo(x, y, x + w, y, r);
        this.closePath(); return this;
    }
}

let currentLang = "vi";

const i18n = {
    vi: {
        introText: "C√¥ng c·ª• ƒëa nƒÉng h·ªó tr·ª£ Animation Timing, T√≠nh to√°n Frame v√† Render.",
        tabConvert: "Time / Frame", tabAnime: "Anime, Toon Frame", tabPose: "D·ª± t√≠nh Pose", tabRender: "Render Time",
        descConvert: "C√¥ng c·ª• chuy·ªÉn ƒë·ªïi qua l·∫°i gi·ªØa th·ªùi l∆∞·ª£ng (Gi√¢y/Ph√∫t/Gi·ªù) v√† S·ªë khung h√¨nh (Frames) theo t·ªëc ƒë·ªô chu·∫©n.",
        descAnime: "Ph√¢n b·ªï kho·∫£ng c√°ch c√°c Keyframe theo quy t·∫Øc Animation (On 1s, 2s, 3s) v√† n·ªôi suy nh·ªãp ƒë·ªô c·∫£nh.",
        descPose: "T·ª± ƒë·ªông ∆∞·ªõc t√≠nh s·ªë l∆∞·ª£ng Pose ch√≠nh v√† Pose ph·ª• tr·ª£ (In-betweens) ph·ª• thu·ªôc v√†o h√†nh ƒë·ªông c·ª• th·ªÉ v√† th·ªùi l∆∞·ª£ng.",
        descRender: "∆Ø·ªõc t√≠nh t·ªïng th·ªùi gian xu·∫•t file (Render) c·ªßa to√†n b·ªô d·ª± √°n d·ª±a tr√™n th·ªùi gian ch·∫°y 1 khung h√¨nh.",

        tipMode: "Ch·ªçn lo·∫°i chuy·ªÉn ƒë·ªïi.", tipFPS_conv: "T·ªëc ƒë·ªô khung h√¨nh (th∆∞·ªùng l√† 24).", tipInput: "Nh·∫≠p t·ªïng s·ªë l∆∞·ª£ng t√≠nh to√°n.",
        tipAnimStyle: "Quy ƒë·ªãnh s·ªë b·∫£n v·∫Ω tr√™n gi√¢y:\n‚Ä¢ On 1s: 24 fps (M∆∞·ª£t).\n‚Ä¢ On 2s: 12 fps (Anime).\n‚Ä¢ On 3s: 8 fps (Ch·∫≠m).",
        tipFPS_anime: "Khung h√¨nh ti√™u chu·∫©n c·ªßa d·ª± √°n.", tipCorePacingAnime: "T·ªëc ƒë·ªô di·ªÖn ho·∫°t c·∫£nh.",
        tipCurveTypeAnime: "ƒê∆∞·ªùng cong t·ªëc ƒë·ªô (Time Remapping):\n‚Ä¢ T√πy ch·ªânh: ƒê·ªì th·ªã t·ªëc ƒë·ªô t√πy ch·ªânh (Y√™u c·∫ßu >3s v√† Logic Nghi√™m ng·∫∑t).",
        tipFocus: "V·∫≠t th·ªÉ ƒëang ƒë·ª©ng im hay di chuy·ªÉn.", tipPose: "T·ªïng s·ªë Pose ch√≠nh c·∫ßn v·∫Ω.", tipFrameRange: "Gi·ªõi h·∫°n th·ªùi gian c·ªßa ƒëo·∫°n di·ªÖn ho·∫°t.",
        tipCalcLogic: "‚Ä¢ Nghi√™m ng·∫∑t: C·ªë ƒë·ªãnh to√°n h·ªçc.\n‚Ä¢ Ng·∫´u nhi√™n: Th√™m sai l·ªách t·ª± nhi√™n.", tipPoseCalcMode: "T·ª± b·ªãa s·ªë gi√¢y hay ·∫•n ƒë·ªãnh tr∆∞·ªõc.", tipPoseSeconds: "ƒê·ªô d√†i c·∫£nh (gi√¢y).",
        tipFPS_pose: "Khung h√¨nh ti√™u chu·∫©n c·ªßa d·ª± √°n.", tipAnimStylePose: "S·ªë frame ƒë·ªÉ gi·ªØ 1 b·∫£n v·∫Ω.", tipFocusTypePose: "Lo·∫°i ƒë·ªëi t∆∞·ª£ng ch√≠nh.",
        tipFocusActionPose: "H√†nh ƒë·ªông ƒë·ªÉ thu·∫≠t to√°n ƒëo ƒë·ªô kh√≥.", tipCorePacingPose: "Nh·ªãp h√†nh ƒë·ªông t·ªïng th·ªÉ.",
        tipCurveTypePose: "Quy lu·∫≠t Easing.\n‚Ä¢ T√πy ch·ªânh: ƒê·ªì th·ªã t·ªëc ƒë·ªô t√πy ch·ªânh (Y√™u c·∫ßu >3s v√† Theo gi√¢y).",
        tipSubPose: "T·ª± ƒë·ªông ch√®n In-betweens.", tipSubPoseLogic: "S·ªë l∆∞·ª£ng b·∫£n v·∫Ω ph·ª• ch√®n gi·ªØa.", tipJerkiness: "K·ªπ thu·∫≠t Hold ·ªü ƒëi·ªÉm ch·∫°m.",
        tipTotalFrames: "T·ªïng frame xu·∫•t.", tipRenderPerFrame: "Th·ªùi gian m√°y render 1 frame.",

        lblMode: "Lo·∫°i t√≠nh", optF2T: "Frame ‚Üí Time", optT2F: "Time ‚Üí Frame",
        lblFPS_conv: "FPS", lblInput: "S·ªë khung h√¨nh/th·ªùi gian", optSec: "Gi√¢y", optMin: "Ph√∫t", optHour: "Gi·ªù",
        lblAnimStyle: "Ki·ªÉu di·ªÖn ho·∫°t", optOn1s: "On 1s (M∆∞·ª£t / H√†nh ƒë·ªông)", optOn2s: "On 2s (Chu·∫©n Anime)", optOn3s: "On 3s (Tƒ©nh / Ch·∫≠m)",
        lblFPS_anime: "FPS g·ªëc", lblCorePacingAnime: "Nh·ªãp t√¢m ƒëi·ªÉm", 
        optCpSuperSlowA: "Super Slow", optCpSlowmoA: "Slow Motion", optCpSlowA: "Ch·∫≠m", optCpNormalA: "B√¨nh th∆∞·ªùng", optCpFastA: "Nhanh", optCpSuperFastA: "C·ª±c nhanh", optCpTimeSplashA: "Time Splash",
        lblCurveTypeAnime: "Lo·∫°i ƒë·ªì th·ªã (Ph√¢n b·ªï)", optCvNoneA: "Kh√¥ng (ƒê·ªÅu)", optCvEaseOutA: "ƒê·ªì th·ªã xu·ªëng (Ch·∫≠m d·∫ßn)", optCvEaseInA: "ƒê·ªì th·ªã l√™n (Nhanh d·∫ßn)", optCvClimaxA: "ƒêi·ªÉm cao tr√†o (Nhanh gi·ªØa)", optCvLowPointA: "ƒêi·ªÉm tr·∫ßm (Ch·∫≠m gi·ªØa)", optCvWaveA: "S√≥ng (Nhanh ch·∫≠m xen k·∫Ω)", optCvCustomA: "T√πy ch·ªânh (ƒê·ªì th·ªã t·ªëc ƒë·ªô)",
        lblFocus: "T√¢m ƒëi·ªÉm & Tr·∫°ng th√°i", optFocScene: "C·∫£nh", optFocChar: "Nh√¢n v·∫≠t/V·∫≠t th·ªÉ", optStateStatic: "Tƒ©nh", optStateDynamic: "ƒê·ªông",
        lblPose: "S·ªë Pose ch√≠nh", lblFrameRange: "Frame B·∫Øt ƒë·∫ßu - K·∫øt th√∫c", 
        lblCalcLogic: "Logic t√≠nh to√°n", optLogicStrict: "To√°n h·ªçc nghi√™m ng·∫∑t", optLogicRandom: "X√°c su·∫•t ng·∫´u nhi√™n",
        warnMathModelAnime: "‚ö† L∆∞u √Ω: M√¥ h√¨nh ƒë·ªì th·ªã v√† to√°n h·ªçc ch·ªâ mang t√≠nh ch·∫•t g·ª£i √Ω tham kh·∫£o.",
        lblPoseCalcMode: "C√°ch t√≠nh to√°n", optPcalcRandom: "X√°c su·∫•t ng·∫´u nhi√™n", optPcalcSeconds: "Theo s·ªë gi√¢y c·∫£nh",
        lblPoseSeconds: "Nh·∫≠p s·ªë gi√¢y c·∫£nh", lblFPS_pose: "FPS g·ªëc", lblAnimStylePose: "Lo·∫°i di·ªÖn ho·∫°t",
        lblFocusTypePose: "Lo·∫°i t√¢m ƒëi·ªÉm", optFocCharP: "Nh√¢n v·∫≠t", optFocObjP: "V·∫≠t th·ªÉ",
        lblFocusActionPose: "H√†nh ƒë·ªông c·ª• th·ªÉ", actTalk: "N√≥i chuy·ªán", actWalk: "ƒêi b·ªô", actRun: "Ch·∫°y", actFight: "ƒê√°nh nhau", actOtherC: "H√†nh ƒë·ªông kh√°c", actFly: "Bay", actFall: "R∆°i", actBreak: "V·ª°/G√£y", actBounce: "N·∫£y", actScale: "Scale", actOtherO: "H√†nh ƒë·ªông kh√°c",
        lblCorePacingPose: "Nh·ªãp t√¢m ƒëi·ªÉm", optCpSuperSlowP: "Super Slow", optCpSlowmoP: "Slow Motion", optCpSlowP: "Ch·∫≠m", optCpNormalP: "B√¨nh th∆∞·ªùng", optCpFastP: "Nhanh", optCpSuperFastP: "C·ª±c nhanh", optCpTimeSplashP: "Time Splash",
        lblCurveTypePose: "Lo·∫°i ƒë·ªì th·ªã", optCvNoneP: "Kh√¥ng", optCvEaseOutP: "ƒê·ªì th·ªã xu·ªëng", optCvEaseInP: "ƒê·ªì th·ªã l√™n", optCvClimaxP: "ƒêi·ªÉm cao tr√†o", optCvLowPointP: "ƒêi·ªÉm tr·∫ßm", optCvWaveP: "S√≥ng", optCvCustomP: "T√πy ch·ªânh (ƒê·ªì th·ªã t·ªëc ƒë·ªô)",
        lblSubPose: "Pose ph·ª• (In-betweens)", optNo: "Kh√¥ng", optYes: "C√≥",
        lblSubPoseLogic: "Quy t·∫Øc Pose ph·ª•", optSpRandom: "Ng·∫´u nhi√™n",
        lblJerkiness: "Gi·∫≠t/Kh·ª±ng (Hold)", optJerkNo: "Kh√¥ng", optJerkFrame: "Theo Frame", optJerkSec: "Theo Gi√¢y",
        warnMathModelPose: "‚ö† L∆∞u √Ω: H·ªá th·ªëng ch·ªâ t√≠nh to√°n g·ª£i √Ω v·ªã tr√≠ l√Ω thuy·∫øt, m·∫≠t ƒë·ªô th·ª±c t·∫ø ph·ª• thu·ªôc b·∫£n v·∫Ω.",
        lblTotalFrames: "T·ªïng frame", lblRenderPerFrame: "Th·ªùi gian render 1 frame (gi√¢y)",
        warningTextRender: "‚ö† Th·ª±c t·∫ø c·∫£nh n·∫∑ng s·∫Ω thay ƒë·ªïi th·ªùi gian.", lblLanguage: "Ng√¥n ng·ªØ:",
        
        dynFrames: "Frames", dynSec: "gi√¢y", dynKeysSugg: "G·ª£i √Ω Keyframe", dynEstPoses: "Pose ∆∞·ªõc t√≠nh",
        dynSubPose: "Pose ph·ª•", dynHold: "Gi·∫≠t/Kh·ª±ng (Hold)", dynHoldMsg1: "Khuy√™n d√πng gi·ªØ th√™m", dynHoldMsg2: "t·∫°i ƒëi·ªÉm ch·∫°m.",
        dynHintFrames: "G·ª£i √Ω h·ª£p l√Ω: ",
        dynHoldCapNote: "(ƒê√£ gi·∫£m xu·ªëng t·ªëi ƒëa 40% c·∫£nh ƒë·ªÉ gi·ªØ nh·ªãp)",
        
        dynClampWarn1: "‚ö†Ô∏è L∆∞u √Ω: Th·ªùi gian c·∫£nh qu√° ng·∫Øn ho·∫∑c nh·ªãp ƒëi·ªáu kh√¥ng kh·ªõp ho√†n to√†n. Keyframe cu·ªëi b·ªã √©p v√†o frame ", dynClampWarn2: " (ph√° v·ª° chu·∫©n nh·ªãp On ", dynClampWarn3: "s).<br>‚ûî G·ª£i √Ω: K√©o d√†i c·∫£nh, ho·∫∑c ƒë·ªïi sang nh·ªãp On 1s/2s ƒë·ªÉ ƒë·ªß kh√¥ng gian ph√¢n b·ªï.",
        dynGraphLimitWarn: "‚ö†Ô∏è C·∫£nh b√°o: V∆∞·ª£t qu√° 25 gi√¢y. ƒê√£ ·∫©n bi·ªÉu ƒë·ªì ƒë·ªì th·ªã ƒë·ªÉ t·ªëi ∆∞u h√≥a hi·ªáu su·∫•t thi·∫øt b·ªã.",
        dynMissingPose: "‚ö†Ô∏è L∆∞u √Ω: B·ªã tr√πng l·∫∑p frame do kho·∫£ng c√°ch qu√° s√°t, s·ªë keyframe b·ªã m·∫•t:",
        dynSubBetween: "L√≥t gi·ªØa",
        dynSubNoSlot: "‚ö†Ô∏è Kh√¥ng ƒë·ªß kho·∫£ng tr·ªëng ƒë·ªÉ ch√®n Pose ph·ª• gi·ªØa",
        dynStaticTitle: "Tr·∫°ng th√°i Tƒ©nh (Static)",
        dynStaticDesc: "C·∫ßn v·∫Ω 1 Pose duy nh·∫•t",
        dynStaticHold: "v√† gi·ªØ xuy√™n su·ªët",
        
        lblVisualGraph: "T·ªïng quan (Gia t·ªëc)", tipVisualGraph: "ƒê·ªì th·ªã bi·ªÉu di·ªÖn ph√¢n b·ªï t·ªëc ƒë·ªô l√Ω thuy·∫øt. ƒê∆∞·ªùng n√©t ƒë·ª©t l√† m·ªëc t·ªëc ƒë·ªô ƒë·ªÅu ƒë·∫∑n.",
        lblDataGraph: "D√≤ng th·ªùi gian (Keyframe)", tipDataGraph: "V·ªã tr√≠ th·ª±c t·∫ø c·ªßa t·ª´ng b·∫£n v·∫Ω tr√™n tr·ª•c th·ªùi gian (K√©o sang ph·∫£i ƒë·ªÉ xem h·∫øt).",
        phStartFrame: "B·∫Øt ƒë·∫ßu (vd: 1)", phEndFrame: "K·∫øt th√∫c (vd: 100)",
        legendMainKey: "Key ch√≠nh", legendSubKey: "Key ph·ª•",
        lblEditorA: "Time Remapping", lblEditorP: "Time Remapping", lblLockA: "Kh√≥a m√∫t", lblLockP: "Kh√≥a m√∫t", lblSmoothA: "M∆∞·ª£t", lblSmoothP: "M∆∞·ª£t", btnResetA: "ƒê·∫∑t l·∫°i", btnResetP: "ƒê·∫∑t l·∫°i",
        
        warnCustomAnime: "‚ö†Ô∏è T√πy ch·ªânh kh√¥ng kh·∫£ d·ª•ng: \"Logic t√≠nh to√°n\" c·∫ßn ch·ªçn ch·∫ø ƒë·ªô To√°n h·ªçc nghi√™m ng·∫∑t v√† th·ªùi l∆∞·ª£ng t·ª´ 3 gi√¢y.",
        warnCustomPose: "‚ö†Ô∏è T√πy ch·ªânh kh√¥ng kh·∫£ d·ª•ng: \"C√°ch t√≠nh to√°n\" c·∫ßn ch·ªçn ch·∫ø ƒë·ªô Theo S·ªë Gi√¢y C·∫£nh v√† th·ªùi l∆∞·ª£ng t·ª´ 3 gi√¢y."
    },
    en: {
        introText: "Versatile tool for Animation Timing, Frame calculations, and Render estimation.",
        tabConvert: "Time / Frame", tabAnime: "Anime, Toon Frame", tabPose: "Pose Estimator", tabRender: "Render Time",
        descConvert: "Tool to seamlessly convert between time duration (Sec/Min/Hour) and total Frames based on FPS.",
        descAnime: "Distribute Keyframes using standard Animation rules (On 1s, 2s, 3s) and calculate scene pacing.",
        descPose: "Automatically estimate main Poses and In-betweens depending on specific action types and duration.",
        descRender: "Estimate the total Render time needed for your project based on a single frame's processing time.",
        
        tipMode: "Select conversion type.", tipFPS_conv: "FPS determines the speed.", tipInput: "Enter the value to compute.",
        tipAnimStyle: "Defines keys per second.", tipFPS_anime: "Standard framerate.", tipCorePacingAnime: "Overall scene speed.",
        tipCurveTypeAnime: "Acceleration curve.\n‚Ä¢ Custom: Custom Speed Curve (Requires >3s & Strict Logic).",
        tipFocus: "Dynamic (moving) or Static (still).", tipPose: "Number of main poses.", tipFrameRange: "Time boundary.",
        tipCalcLogic: "Strict math or Random deviation.", tipPoseCalcMode: "Random or Custom seconds.", tipPoseSeconds: "Desired duration.",
        tipFPS_pose: "Standard framerate.", tipAnimStylePose: "Keyframe density.", tipFocusTypePose: "Character or Object.",
        tipFocusActionPose: "Specific action.", tipCorePacingPose: "Overall speed.",
        tipCurveTypePose: "Acceleration curve.\n‚Ä¢ Custom: Custom Speed Curve (Requires >3s & Fixed Seconds).",
        tipSubPose: "Generate In-between poses.", tipSubPoseLogic: "In-between padding rule.", tipJerkiness: "Hold frames at impact.",
        tipTotalFrames: "Total frames to render.", tipRenderPerFrame: "Actual time to render a single frame.",

        lblMode: "Mode", optF2T: "Frame ‚Üí Time", optT2F: "Time ‚Üí Frame",
        lblFPS_conv: "FPS", lblInput: "Input Value", optSec: "Seconds", optMin: "Minutes", optHour: "Hours",
        lblAnimStyle: "Anim Style", optOn1s: "On 1s", optOn2s: "On 2s", optOn3s: "On 3s",
        lblFPS_anime: "Base FPS", lblCorePacingAnime: "Core Pacing", 
        optCpSuperSlowA: "Super Slow", optCpSlowmoA: "Slow Motion", optCpSlowA: "Slow", optCpNormalA: "Normal", optCpFastA: "Fast", optCpSuperFastA: "Super Fast", optCpTimeSplashA: "Time Splash",
        lblCurveTypeAnime: "Curve Type", optCvNoneA: "None (Linear)", optCvEaseOutA: "Ease Out", optCvEaseInA: "Ease In", optCvClimaxA: "Climax", optCvLowPointA: "Low Point", optCvWaveA: "Wave", optCvCustomA: "Custom (Speed Curve)",
        lblFocus: "Focus & State", optFocScene: "Scene", optFocChar: "Character/Object", optStateStatic: "Static", optStateDynamic: "Dynamic",
        lblPose: "Pose Count", lblFrameRange: "Start - End Frame", 
        lblCalcLogic: "Logic", optLogicStrict: "Strict Math", optLogicRandom: "Random Prob",
        warnMathModelAnime: "‚ö† Note: Graph models are for theoretical reference only.",
        lblPoseCalcMode: "Calc Mode", optPcalcRandom: "Random Prob", optPcalcSeconds: "By Scene Seconds",
        lblPoseSeconds: "Enter Seconds", lblFPS_pose: "Base FPS", lblAnimStylePose: "Anim Style",
        lblFocusTypePose: "Focus Type", optFocCharP: "Character", optFocObjP: "Object",
        lblFocusActionPose: "Specific Action", actTalk: "Talking", actWalk: "Walking", actRun: "Running", actFight: "Fighting", actOtherC: "Other Action", actFly: "Flying", actFall: "Falling", actBreak: "Breaking", actBounce: "Bouncing", actScale: "Scaling", actOtherO: "Other Action",
        lblCorePacingPose: "Core Pacing", optCpSuperSlowP: "Super Slow", optCpSlowmoP: "Slow Motion", optCpSlowP: "Slow", optCpNormalP: "Normal", optCpFastP: "Fast", optCpSuperFastP: "Super Fast", optCpTimeSplashP: "Time Splash",
        lblCurveTypePose: "Curve Type", optCvNoneP: "None", optCvEaseOutP: "Ease Out", optCvEaseInP: "Ease In", optCvClimaxP: "Climax", optCvLowPointP: "Low Point", optCvWaveP: "Wave", optCvCustomP: "Custom (Speed Curve)",
        lblSubPose: "Add In-betweens", optNo: "No", optYes: "Yes", lblSubPoseLogic: "In-between Logic", optSpRandom: "Random Prob",
        lblJerkiness: "Stutter / Hold", optJerkNo: "No", optJerkFrame: "By Frames", optJerkSec: "By Seconds",
        warnMathModelPose: "‚ö† Note: Theoretical suggestion; real density depends on the drawing.",
        lblTotalFrames: "Total Frames", lblRenderPerFrame: "Time per frame",
        warningTextRender: "‚ö† Reference only.", lblLanguage: "Language:",
        
        dynFrames: "Frames", dynSec: "sec", dynKeysSugg: "Suggested Keys", dynEstPoses: "Est. Main Poses", dynSubPose: "Sub Poses", dynHold: "Hold Effect", dynHoldMsg1: "Suggested holding", dynHoldMsg2: "at impact.", dynHintFrames: "Suggested range: ",
        dynHoldCapNote: "(Capped at 40% of scene to preserve rhythm)",
        dynClampWarn1: "‚ö†Ô∏è Note: Scene duration is too short or pacing is mismatched. The last key was forced to frame ", dynClampWarn2: " (breaking the On ", dynClampWarn3: "s rhythm).<br>‚ûî Fix: Increase scene duration or switch to On 1s/2s.",
        dynGraphLimitWarn: "‚ö†Ô∏è Warning: Scene > 25s. Graphs disabled to optimize device performance.",
        dynMissingPose: "‚ö†Ô∏è Note: Duplicate frames due to tight spacing ‚Äî poses lost:",
        dynSubBetween: "Between",
        dynSubNoSlot: "‚ö†Ô∏è Not enough space to insert sub poses between",
        dynStaticTitle: "Static State",
        dynStaticDesc: "Draw 1 single Pose",
        dynStaticHold: "and hold for",
        
        lblVisualGraph: "Overview (Acceleration)", tipVisualGraph: "Theoretical speed distribution. Dotted line is constant speed.", 
        lblDataGraph: "Timeline (Keyframes)", tipDataGraph: "Actual frame placement on the timeline (Scrollable horizontally).",
        phStartFrame: "Start (e.g., 1)", phEndFrame: "End (e.g., 100)", legendMainKey: "Main Key", legendSubKey: "Sub Key",
        lblEditorA: "Time Remapping", lblEditorP: "Time Remapping", lblLockA: "Lock Ends", lblLockP: "Lock Ends", lblSmoothA: "Smooth", lblSmoothP: "Smooth", btnResetA: "Reset", btnResetP: "Reset",
        
        warnCustomAnime: "‚ö†Ô∏è Custom not available: \"Logic\" must be set to Strict Math and duration >= 3 seconds.",
        warnCustomPose: "‚ö†Ô∏è Custom not available: \"Calc Mode\" must be set to By Scene Seconds and duration >= 3 seconds."
    }
};

// ================================================================
// CUSTOM CURVE LOGIC
// ================================================================
let customData = {
    anime: { points: [{x:0, y:0.5}, {x:0.5, y:0.5}, {x:1, y:0.5}], activeNode: null, lut: [] },
    pose:  { points: [{x:0, y:0.5}, {x:0.5, y:0.5}, {x:1, y:0.5}], activeNode: null, lut: [] }
};

function updateCustomLUT(tab) {
    let pts = customData[tab].points; let lut = []; let sum = 0; let steps = 1000;
    let isSmoothEl = document.getElementById("smoothCurve_" + tab);
    let isSmooth = isSmoothEl ? isSmoothEl.checked : true;
    for(let i=0; i<=steps; i++) {
        let x = i / steps;
        let y = isSmooth ? splineCustomCurve(x, pts) : lerpCustomCurve(x, pts);
        y = Math.max(0, Math.min(1, y));
        let speed = Math.pow(10, (y - 0.5) * 2);
        sum += speed; lut.push(sum);
    }
    let total = lut[steps]; if(total === 0) total = 1;
    for(let i=0; i<=steps; i++) lut[i] /= total;
    customData[tab].lut = lut;
}

function resetCustomPoints(tab) {
    customData[tab].points = [{x:0, y:0.5}, {x:0.5, y:0.5}, {x:1, y:0.5}];
    updateCustomLUT(tab); drawCustomEditor(tab);
    if(tab === 'anime') updateAnime(); else updatePoseEst();
}

function lerpCustomCurve(x, points) {
    if(x <= points[0].x) return points[0].y;
    if(x >= points[points.length-1].x) return points[points.length-1].y;
    for(let i=0; i<points.length-1; i++) {
        if(x >= points[i].x && x <= points[i+1].x) {
            let tl = (x - points[i].x) / (points[i+1].x - points[i].x);
            return points[i].y + tl * (points[i+1].y - points[i].y);
        }
    }
    return x;
}

function splineCustomCurve(x, points) {
    if(x <= points[0].x) return points[0].y;
    if(x >= points[points.length-1].x) return points[points.length-1].y;
    let i = 0;
    while(i < points.length - 2 && x > points[i+1].x) i++;
    let p1 = points[i], p2 = points[i+1];
    let p0 = i > 0 ? points[i-1] : { x: p1.x-(p2.x-p1.x), y: p1.y-(p2.y-p1.y) };
    let p3 = i+2 < points.length ? points[i+2] : { x: p2.x+(p2.x-p1.x), y: p2.y+(p2.y-p1.y) };
    let tl = (x - p1.x) / (p2.x - p1.x); let t2 = tl*tl; let t3 = t2*tl;
    let v0 = (p2.y - p0.y) * 0.5; let v1 = (p3.y - p1.y) * 0.5;
    let rawVal = (2*p1.y - 2*p2.y + v0 + v1)*t3 + (-3*p1.y + 3*p2.y - 2*v0 - v1)*t2 + v0*tl + p1.y;
    return Math.max(0, Math.min(1, rawVal));
}

function getPacingCurve(x, type, tab) {
    if(type === 'custom') {
        if(!customData[tab].lut || customData[tab].lut.length === 0) updateCustomLUT(tab);
        let lut = customData[tab].lut; let steps = lut.length - 1;
        let exactIdx = x * steps; let idx1 = Math.floor(exactIdx); let idx2 = Math.ceil(exactIdx);
        if(idx1 < 0) idx1 = 0; if(idx2 > steps) idx2 = steps;
        if(idx1 === idx2) return lut[idx1];
        let tl = exactIdx - idx1; return lut[idx1]*(1-tl) + lut[idx2]*tl;
    }
    if(type === 'ease_in')   return x * x * x;
    if(type === 'ease_out')  return 1 - Math.pow(1-x, 3);
    if(type === 'climax')    return x < 0.5 ? 4*x*x*x : 1 - Math.pow(-2*x+2, 3)/2;
    if(type === 'low_point') return x + 0.15 * Math.sin(x * Math.PI * 2); // ch·∫≠m gi·ªØa, nhanh 2 ƒë·∫ßu
    if(type === 'wave')      return Math.max(0, Math.min(1, x + 0.1 * Math.sin(x * Math.PI * 4)));
    return x;
}

// ================================================================
// CUSTOM CURVE EDITOR DRAWING ‚Äî Styled like D√≤ng th·ªùi gian
// ================================================================
const EDITOR_W = 530;
const EDITOR_H = 140;

function drawCustomEditor(tab) {
    let canvas = document.getElementById("customCanvas_" + tab); if(!canvas) return;
    let dpr = window.devicePixelRatio || 1;
    let w = EDITOR_W, h = EDITOR_H;
    if(canvas.width !== w * dpr) {
        canvas.width = w * dpr; canvas.height = h * dpr;
        canvas.style.width = w + "px"; canvas.style.height = h + "px";
        canvas.getContext("2d").setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    let ctx = canvas.getContext("2d");
    ctx.clearRect(0, 0, w, h);
    
    let padX = 30, padY = 15;
    let usableW = w - padX * 2;
    let usableH = h - padY * 2;
    let midY = h / 2;
    
    // Grid lines (matching timeline style)
    ctx.strokeStyle = "rgba(255,255,255,0.06)";
    ctx.lineWidth = 1;
    for(let xi = 0; xi <= 4; xi++) {
        let gx = padX + (xi / 4) * usableW;
        ctx.beginPath(); ctx.moveTo(gx, padY); ctx.lineTo(gx, h - padY); ctx.stroke();
    }
    
    // Speed reference labels
    ctx.fillStyle = "rgba(255,255,255,0.35)";
    ctx.font = "10px 'Be Vietnam Pro', sans-serif";
    ctx.textAlign = "left"; ctx.textBaseline = "middle";
    ctx.fillText("10x", padX + 3, padY + 8);
    ctx.fillText("1x",  padX + 3, midY - 8);
    ctx.fillText("0.1x",padX + 3, h - padY - 8);
    
    // Mid reference line (1x speed) ‚Äî dashed like static graph
    ctx.beginPath(); ctx.moveTo(padX, midY); ctx.lineTo(w - padX, midY);
    ctx.strokeStyle = "rgba(255, 204, 102, 0.35)";
    ctx.setLineDash([4, 4]); ctx.lineWidth = 1.5; ctx.stroke(); ctx.setLineDash([]);
    
    // Top/bottom reference lines
    ctx.strokeStyle = "rgba(255,255,255,0.08)"; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(padX, padY); ctx.lineTo(w - padX, padY); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(padX, h - padY); ctx.lineTo(w - padX, h - padY); ctx.stroke();
    
    // Bottom axis line ‚Äî matching timeline baseline
    ctx.beginPath(); ctx.moveTo(padX - 10, h - padY); ctx.lineTo(w - padX + 10, h - padY);
    ctx.strokeStyle = "#1e3a5f"; ctx.lineWidth = 2.5; ctx.stroke();
    
    let pts = customData[tab].points;
    let isLocked = document.getElementById("lockEnd_" + tab).checked;
    let isSmooth = document.getElementById("smoothCurve_" + tab).checked;
    
    // Speed curve fill area
    ctx.beginPath();
    if(isSmooth) {
        ctx.moveTo(padX, h - padY);
        for(let xi = 0; xi <= 1; xi += 0.005) {
            let val = splineCustomCurve(xi, pts);
            val = Math.max(0, Math.min(1, val));
            let px = padX + xi * usableW;
            let py = h - padY - val * usableH;
            ctx.lineTo(px, py);
        }
    } else {
        ctx.moveTo(padX, h - padY);
        pts.forEach(p => {
            ctx.lineTo(padX + p.x * usableW, h - padY - p.y * usableH);
        });
    }
    ctx.lineTo(w - padX, h - padY);
    ctx.closePath();
    ctx.fillStyle = "rgba(0, 204, 255, 0.06)"; ctx.fill();
    
    // Speed curve line ‚Äî same color/weight as timeline line
    ctx.beginPath();
    if(isSmooth) {
        let first = true;
        for(let xi = 0; xi <= 1; xi += 0.005) {
            let val = splineCustomCurve(xi, pts);
            val = Math.max(0, Math.min(1, val));
            let px = padX + xi * usableW;
            let py = h - padY - val * usableH;
            if(first) { ctx.moveTo(px, py); first = false; } else ctx.lineTo(px, py);
        }
        let lastVal = splineCustomCurve(1, pts);
        ctx.lineTo(padX + usableW, h - padY - Math.max(0,Math.min(1,lastVal)) * usableH);
    } else {
        pts.forEach((p, i) => {
            let px = padX + p.x * usableW; let py = h - padY - p.y * usableH;
            if(i===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
        });
    }
    ctx.strokeStyle = "#00ccff"; ctx.lineWidth = 2.5;
    ctx.lineCap = "round"; ctx.lineJoin = "round"; ctx.stroke();
    
    // Control points ‚Äî styled like timeline key dots
    pts.forEach((p, i) => {
        let px = padX + p.x * usableW;
        let py = h - padY - p.y * usableH;
        let isEndNode = (i === 0 || i === pts.length - 1);
        
        // Vertical drop line to baseline
        ctx.beginPath(); ctx.moveTo(px, py); ctx.lineTo(px, h - padY);
        ctx.strokeStyle = "rgba(0, 204, 255, 0.2)"; ctx.lineWidth = 1.5; ctx.stroke();
        
        if(isEndNode && isLocked) {
            // Locked end: small dim dot
            ctx.beginPath(); ctx.arc(px, py, 3, 0, Math.PI*2);
            ctx.fillStyle = "rgba(0, 204, 255, 0.4)"; ctx.fill();
            // Baseline tick
            ctx.beginPath(); ctx.arc(px, h - padY, 4, 0, Math.PI*2);
            ctx.fillStyle = "rgba(0, 204, 255, 0.3)"; ctx.fill();
        } else {
            // Curve node: white dot like timeline main key
            ctx.beginPath(); ctx.arc(px, py, 5, 0, Math.PI*2);
            ctx.fillStyle = "#fff"; ctx.fill();
            ctx.strokeStyle = "rgba(0, 204, 255, 0.6)"; ctx.lineWidth = 1.5; ctx.stroke();
            // Baseline dot ‚Äî yellow like timeline
            ctx.beginPath(); ctx.arc(px, h - padY, 5, 0, Math.PI*2);
            ctx.fillStyle = "#ffcc66"; ctx.fill();
        }
    });
}

function initCustomCanvas(tab) {
    let canvas = document.getElementById("customCanvas_" + tab);
    if(!canvas || canvas.dataset.initialized) return;
    canvas.dataset.initialized = "true";
    let isDragging = false;
    
    // Make canvas fixed size, container scrollable (matching graph-wrapper)
    canvas.width = EDITOR_W * (window.devicePixelRatio || 1);
    canvas.height = EDITOR_H * (window.devicePixelRatio || 1);
    canvas.style.width = EDITOR_W + "px";
    canvas.style.height = EDITOR_H + "px";
    canvas.getContext("2d").setTransform(window.devicePixelRatio || 1, 0, 0, window.devicePixelRatio || 1, 0, 0);
    
    function getMousePos(e) {
        let rect = canvas.getBoundingClientRect();
        let clientX = e.touches ? e.touches[0].clientX : e.clientX;
        let clientY = e.touches ? e.touches[0].clientY : e.clientY;
        return { x: clientX - rect.left, y: clientY - rect.top };
    }
    
    function handleDown(e) {
        e.preventDefault();
        let pos = getMousePos(e);
        let padX = 30, padY = 15;
        let usableW = EDITOR_W - padX*2; let usableH = EDITOR_H - padY*2;
        let pts = customData[tab].points;
        let isLocked = document.getElementById("lockEnd_" + tab).checked;
        let startIdx = isLocked ? 1 : 0;
        let endIdx = isLocked ? pts.length - 1 : pts.length;
        for(let i = startIdx; i < endIdx; i++) {
            let px = padX + pts[i].x * usableW;
            let py = EDITOR_H - padY - pts[i].y * usableH;
            if(Math.hypot(pos.x - px, pos.y - py) < 20) {
                isDragging = true; customData[tab].activeNode = i; break;
            }
        }
    }
    
    function handleMove(e) {
        if(!isDragging || customData[tab].activeNode === null) return;
        e.preventDefault();
        let pos = getMousePos(e);
        let padX = 30, padY = 15;
        let usableW = EDITOR_W - padX*2; let usableH = EDITOR_H - padY*2;
        let i = customData[tab].activeNode;
        let pts = customData[tab].points;
        let newX = (pos.x - padX) / usableW;
        let newY = (EDITOR_H - padY - pos.y) / usableH;
        if(i === 0) {
            pts[i].x = 0; pts[i].y = Math.max(0, Math.min(1, newY));
        } else if(i === pts.length - 1) {
            pts[i].x = 1; pts[i].y = Math.max(0, Math.min(1, newY));
        } else {
            let minX = pts[i-1].x + 0.02; let maxX = pts[i+1].x - 0.02;
            pts[i].x = Math.max(minX, Math.min(maxX, newX));
            pts[i].y = Math.max(0, Math.min(1, newY));
        }
        updateCustomLUT(tab); drawCustomEditor(tab);
        if(tab === 'anime') updateAnime(); else updatePoseEst();
    }
    
    function handleUp() { isDragging = false; customData[tab].activeNode = null; }
    
    canvas.addEventListener('mousedown', handleDown);
    canvas.addEventListener('mousemove', handleMove);
    window.addEventListener('mouseup', handleUp);
    canvas.addEventListener('touchstart', handleDown, {passive:false});
    canvas.addEventListener('touchmove', handleMove, {passive:false});
    window.addEventListener('touchend', handleUp);
    
    document.getElementById("lockEnd_" + tab).addEventListener('change', () => drawCustomEditor(tab));
    document.getElementById("smoothCurve_" + tab).addEventListener('change', () => {
        updateCustomLUT(tab); drawCustomEditor(tab);
        if(tab==='anime') updateAnime(); else updatePoseEst();
    });
}

function modifyCustomPoints(tab, delta) {
    let pts = customData[tab].points;
    if(delta > 0 && pts.length < 6) {
        let newPts = [pts[0]];
        for(let i=1; i<pts.length; i++) {
            newPts.push({ x:(pts[i-1].x+pts[i].x)/2, y:(pts[i-1].y+pts[i].y)/2 });
            newPts.push(pts[i]);
        }
        while(newPts.length > pts.length + 1 && newPts.length > 6) newPts.splice(2, 1);
        customData[tab].points = newPts;
    } else if(delta < 0 && pts.length > 3) {
        pts.splice(pts.length-2, 1);
    }
    updateCustomLUT(tab); drawCustomEditor(tab);
    if(tab === 'anime') updateAnime(); else updatePoseEst();
}

function toggleAnimeCustom() {
    let curve = document.getElementById("curveTypeAnime").value;
    let logic = document.getElementById("calcLogic").value;
    let fps = parseFloat(document.getElementById("fpsAnime").value) || 24;
    let sf = parseInt(document.getElementById("startFrame").value) || 1;
    let ef = parseInt(document.getElementById("endFrame").value) || 100;
    let timeSec = (ef - sf + 1) / fps;
    let wrap = document.getElementById("customEditorWrap_anime");
    let warn = document.getElementById("warnCustomAnime");
    if(curve === "custom") {
        wrap.classList.remove("hidden");
        if(logic !== "strict" || timeSec < 3) {
            wrap.classList.add("disabled");
            if(warn) { warn.innerText = i18n[currentLang].warnCustomAnime; warn.classList.remove("hidden"); }
        } else {
            wrap.classList.remove("disabled");
            if(warn) warn.classList.add("hidden");
            initCustomCanvas('anime'); requestAnimationFrame(() => drawCustomEditor('anime'));
        }
    } else {
        wrap.classList.add("hidden");
        if(warn) warn.classList.add("hidden");
    }
}

function togglePoseCustom() {
    let curve = document.getElementById("curveTypePose").value;
    let mode = document.getElementById("poseCalcMode").value;
    let sec = parseFloat(document.getElementById("poseSeconds").value) || 0;
    let wrap = document.getElementById("customEditorWrap_pose");
    let warn = document.getElementById("warnCustomPose");
    if(curve === "custom") {
        wrap.classList.remove("hidden");
        if(mode !== "seconds" || sec < 3) {
            wrap.classList.add("disabled");
            if(warn) { warn.innerText = i18n[currentLang].warnCustomPose; warn.classList.remove("hidden"); }
        } else {
            wrap.classList.remove("disabled");
            if(warn) warn.classList.add("hidden");
            initCustomCanvas('pose'); requestAnimationFrame(() => drawCustomEditor('pose'));
        }
    } else {
        wrap.classList.add("hidden");
        if(warn) warn.classList.add("hidden");
    }
}

// ================================================================
// GRAPH RENDERING
// ================================================================
function setupHighResCanvas(canvasId, width, height) {
    let canvas = document.getElementById(canvasId); if(!canvas) return null;
    let ctx = canvas.getContext("2d"); let dpr = window.devicePixelRatio || 1;
    canvas.width = width * dpr; canvas.height = height * dpr;
    canvas.style.width = width + "px"; canvas.style.height = height + "px";
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); return { canvas, ctx, w: width, h: height };
}

function drawPill(ctx, text, x, y, bgColor, color) {
    ctx.font = "600 11px 'Be Vietnam Pro', sans-serif"; let tw = ctx.measureText(text).width;
    ctx.fillStyle = bgColor; ctx.beginPath(); ctx.roundRect(x - tw/2 - 7, y - 10, tw + 14, 20, 10); ctx.fill();
    ctx.fillStyle = color; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText(text, x, y + 1);
}

function renderStaticCurve(canvasId, curveType, tab) {
    let res = setupHighResCanvas(canvasId, 530, 110); if(!res) return;
    let { ctx, w, h } = res; let padX = 30, padY = 15; let usableW = w - padX*2; let usableH = h - padY*2; let midY = h/2;
    ctx.clearRect(0, 0, w, h);
    let dx = 0.001; let rawSpeeds = [];
    for(let i=0; i<=100; i++) {
        let x = i/100; let x0 = Math.max(0,x-dx); let x1 = Math.min(1,x+dx);
        let y0 = getPacingCurve(x0, curveType, tab); let y1 = getPacingCurve(x1, curveType, tab);
        rawSpeeds.push((x1>x0) ? (y1-y0)/(x1-x0) : 1);
    }
    ctx.beginPath(); ctx.moveTo(padX, midY); ctx.lineTo(w-padX, midY);
    ctx.strokeStyle = "rgba(255,204,102,0.4)"; ctx.setLineDash([4,4]); ctx.lineWidth = 1.5; ctx.stroke(); ctx.setLineDash([]);
    ctx.beginPath();
    for(let i=0; i<=100; i++) {
        let x = i/100; let yOffset = (rawSpeeds[i]-1) * (usableH/3);
        let yPos = Math.max(padY-5, Math.min(h-padY+5, midY - yOffset));
        if(i===0) ctx.moveTo(padX + x*usableW, yPos); else ctx.lineTo(padX + x*usableW, yPos);
    }
    ctx.strokeStyle = "#ffcc66"; ctx.lineWidth = 3; ctx.lineCap = "round"; ctx.lineJoin = "round"; ctx.stroke();
    ctx.beginPath(); ctx.moveTo(padX-10, h-padY); ctx.lineTo(w-padX+10, h-padY);
    ctx.strokeStyle = "#1e3a5f"; ctx.lineWidth = 2.5; ctx.stroke();
}

function renderGraph(canvasId, mainKeys, subKeys, minF, maxF, requiredWidth) {
    let padYBottom = 45;
    let res = setupHighResCanvas(canvasId, requiredWidth, 90 + padYBottom); if(!res) return;
    let { ctx, w, h } = res; let padX = 30, padY = 25; let usableW = w-padX*2; let usableH = h-padYBottom-padY;
    let range = maxF - minF; if(range <= 0) range = 1;
    ctx.beginPath();
    mainKeys.forEach((key, index) => {
        let x = padX + ((key-minF)/range)*usableW;
        let y = h - padYBottom - (mainKeys.length>1 ? (index/(mainKeys.length-1))*usableH : usableH/2);
        if(index===0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    });
    ctx.strokeStyle = "#00ccff"; ctx.lineWidth = 3; ctx.lineCap = "round"; ctx.lineJoin = "round"; ctx.stroke();
    ctx.beginPath(); ctx.moveTo(padX-10, h-padYBottom); ctx.lineTo(w-padX+10, h-padYBottom);
    ctx.strokeStyle = "#1e3a5f"; ctx.lineWidth = 2.5; ctx.stroke();
    if(subKeys && subKeys.length > 0) {
        let dedupSubs = [...new Set(subKeys)];
        dedupSubs.forEach(key => {
            let x = padX + ((key-minF)/range)*usableW;
            ctx.beginPath(); ctx.arc(x, h-padYBottom, 4, 0, Math.PI*2); ctx.fillStyle = "#00ccff"; ctx.fill();
            drawPill(ctx, key, x, h-padYBottom-18, "rgba(0,204,255,0.15)", "#00ccff");
        });
    }
    let lastTextX = -999; let staggerLevel = 0;
    mainKeys.forEach((key, index) => {
        let x = padX + ((key-minF)/range)*usableW;
        let y = h-padYBottom - (mainKeys.length>1 ? (index/(mainKeys.length-1))*usableH : usableH/2);
        ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x, h-padYBottom);
        ctx.strokeStyle = "rgba(0,204,255,0.3)"; ctx.lineWidth = 1.5; ctx.stroke();
        ctx.beginPath(); ctx.arc(x, y, 4, 0, Math.PI*2); ctx.fillStyle = "#fff"; ctx.fill();
        ctx.beginPath(); ctx.arc(x, h-padYBottom, 5, 0, Math.PI*2); ctx.fillStyle = "#ffcc66"; ctx.fill();
        if(x - lastTextX < 32) { staggerLevel = (staggerLevel+1)%3; } else { staggerLevel = 0; }
        lastTextX = x; let textY = h-padYBottom+12+(staggerLevel*14);
        drawPill(ctx, key, x, textY, "rgba(255,204,102,0.15)", "#ffcc66");
    });
}

// ================================================================
// TAB SWITCHING
// ================================================================
function switchTab(tab) {
    ["convertMode","animeMode","poseMode","renderMode"].forEach(id => document.getElementById(id).classList.add("hidden"));
    ["tabConvert","tabAnime","tabPose","tabRender"].forEach(id => document.getElementById(id).classList.remove("active"));
    let modeId = tab + "Mode";
    document.getElementById(modeId).classList.remove("hidden");
    document.getElementById("tab" + tab.charAt(0).toUpperCase() + tab.slice(1)).classList.add("active");
    if(tab === "convert") updateConvert();
    if(tab === "anime") { toggleAnimePoseInput(); toggleAnimeCustom(); updateAnime(); }
    if(tab === "pose")  { togglePoseSettings(); togglePoseCustom(); updatePoseEst(); }
    if(tab === "render") updateRender();
    updateAllCustomSelects();
}

function setField(id, val) { document.getElementById(id).value = val; }

// ================================================================
// CONVERT
// ================================================================
function updateConvert() {
    let mode = document.getElementById("mode").value; let fps = parseFloat(document.getElementById("fps").value);
    let val = parseFloat(document.getElementById("inputValue").value); let tUnit = document.getElementById("timeUnit");
    let isTime2Frame = (mode === "t2f");
    tUnit.classList.toggle("hidden", !isTime2Frame);
    if(tUnit.parentNode && tUnit.parentNode.classList.contains("custom-select-wrapper")) tUnit.parentNode.classList.toggle("hidden", !isTime2Frame);
    if(isNaN(val)||isNaN(fps)||fps<=0||val<0) { document.getElementById("convertOutput").innerHTML = "‚Äî"; return; }
    if(mode === "f2t") {
        let totalSec = val/fps; let mainStr = totalSec.toFixed(3) + " " + i18n[currentLang].dynSec;
        let h2 = Math.floor(totalSec/3600), m = Math.floor((totalSec%3600)/60), s = parseFloat((totalSec%60).toFixed(3));
        let subStr = (h2>0||m>0) ? `<span class="sub-result">‚âà ${h2>0?h2+"h ":""}${m}m ${s}s</span>` : "";
        document.getElementById("convertOutput").innerHTML = mainStr + subStr;
    } else {
        let frames = Math.round(val * parseFloat(tUnit.value) * fps);
        document.getElementById("convertOutput").innerHTML = frames + " " + i18n[currentLang].dynFrames;
    }
}

// ================================================================
// ANIME TAB
// ================================================================
function toggleAnimePoseInput() {
    let isStatic = document.getElementById("focusState").value === "static";
    document.getElementById("poseRow").classList.toggle("hidden", isStatic);
    document.getElementById("rowCorePacingA").classList.toggle("hidden", isStatic);
    document.getElementById("rowCurveTypeA").classList.toggle("hidden", isStatic);
    document.getElementById("rowLogicA").classList.toggle("hidden", isStatic);
}

function updateAnime() {
    let focusState = document.getElementById("focusState").value;
    let style = parseInt(document.getElementById("animStyle").value);
    let fps = parseFloat(document.getElementById("fpsAnime").value) || 24;
    let curve = document.getElementById("curveTypeAnime").value;
    let poses = parseInt(document.getElementById("poseCount").value) || 1;
    let logic = document.getElementById("calcLogic").value;
    let sfInput = document.getElementById("startFrame"); let efInput = document.getElementById("endFrame");
    let sf = parseInt(sfInput.value); let ef = parseInt(efInput.value);
    if(isNaN(sf)) { sf = 1; sfInput.value = 1; } if(isNaN(ef)) { ef = 100; efInput.value = 100; }
    if(sf > ef) { let tmp = sf; sf = ef; ef = tmp; sfInput.value = sf; efInput.value = ef; }
    let totalF = ef - sf + 1; let t = i18n[currentLang];
    let isTooLong = (totalF/fps) > 25;
    let out = `T·ªïng: <span style="color:white">${totalF}</span> frames<br>`;
    
    if(focusState === "dynamic") {
        let isShortage = totalF < style * poses;
        let isCustomValid = !(curve==='custom' && (logic!=='strict' || (totalF/fps)<3));
        if(!isCustomValid) {
            out += `<div class="warning" style="text-align:left; margin-top:15px; color:#ffcc66; border-color:#ffcc66;">${t.warnCustomAnime}</div>`;
            document.getElementById("animeOutput").innerHTML = out; return;
        }
        if(curve==='custom') updateCustomLUT('anime');
        let keys = []; let isClamped = false; let clampedTo = 0; let missingPoses = 0;
        if(poses === 1) keys.push(sf);
        else {
            for(let i=0; i<poses; i++) {
                let x = i/(poses-1); let p = sf + getPacingCurve(x, curve, 'anime') * (totalF-1);
                if(logic==="random" && i>0 && i<poses-1 && curve!=='custom') {
                    let prevX=(i-1)/(poses-1); let nextX=(i+1)/(poses-1);
                    let prevP=sf+getPacingCurve(prevX,curve,'anime')*(totalF-1);
                    let nextP=sf+getPacingCurve(nextX,curve,'anime')*(totalF-1);
                    let maxJitter=Math.min(p-prevP,nextP-p)*0.4;
                    p+=(Math.random()*maxJitter*2)-maxJitter;
                }
                let rawSnap = sf + Math.round((p-sf)/style)*style;
                keys.push(Math.max(sf, Math.min(ef, rawSnap)));
            }
            let uniqueKeys = [...new Set(keys)].sort((a,b)=>a-b);
            missingPoses = poses - uniqueKeys.length; keys = uniqueKeys;
            let lastKey = keys[keys.length-1];
            if(lastKey!==ef && (lastKey-sf)%style!==0) { isClamped=true; clampedTo=lastKey; }
            else if(keys.length>1) {
                let secondLast=keys[keys.length-2];
                if(lastKey===ef && (ef-secondLast)%style!==0) { isClamped=true; clampedTo=lastKey; }
            }
        }
        out += `<div class="box-result"><b>${t.dynKeysSugg}:</b><br>${keys.join(" ‚ûî ")}</div>`;
        if(missingPoses>0) out += `<div class="warning" style="text-align:left;margin-top:15px;color:#ffcc66;border-color:#ffcc66;">${t.dynMissingPose} <b>${missingPoses}</b>.</div>`;
        if(isClamped||isShortage) out += `<div class="warning" style="text-align:left;margin-top:15px;">${t.dynClampWarn1}<b>${clampedTo||keys[keys.length-1]}</b>${t.dynClampWarn2}<b>${style}</b>${t.dynClampWarn3}</div>`;
        if(isTooLong) {
            out += `<div class="warning" style="text-align:left;margin-top:15px;color:#ff6b6b;border-color:#ff6b6b;">${t.dynGraphLimitWarn}</div>`;
        } else {
            out += `
            <div class="graph-title" style="margin-top:25px;margin-bottom:8px;"><span>${t.lblVisualGraph}</span><span class="tooltip" data-tip="${t.tipVisualGraph}">?</span></div>
            <div class="static-graph-wrapper"><canvas id="animeStaticGraph" class="graph-canvas"></canvas></div>
            <div class="graph-title" style="margin-top:25px;margin-bottom:8px;"><span>${t.lblDataGraph}</span><span class="tooltip" data-tip="${t.tipDataGraph}">?</span></div>
            <div class="graph-wrapper"><canvas id="animeGraph" class="graph-canvas"></canvas></div>
            <div class="graph-legend-box"><span style="color:#ffcc66">‚óè</span><span data-i18n="legendMainKey">${t.legendMainKey}</span></div>`;
        }
        document.getElementById("animeOutput").innerHTML = out;
        if(!isTooLong) {
            let requiredWidth = Math.max(530, keys.length*40);
            renderStaticCurve("animeStaticGraph", curve, 'anime');
            renderGraph("animeGraph", keys, [], sf, ef, requiredWidth);
        }
    } else {
        // [FIX P-15] D√πng i18n thay v√¨ hardcode
        out += `<div class="box-result">
            <b style="color:#ffcc66;">${t.dynStaticTitle}</b><br>
            ${t.dynStaticDesc} (${currentLang==='vi'?'ƒë·∫∑t t·∫°i':'placed at'} frame ${sf}) ${t.dynStaticHold} ${totalF} frames.
        </div>`;
        document.getElementById("animeOutput").innerHTML = out;
    }
}

// ================================================================
// POSE TAB ‚Äî v·ªõi t·∫•t c·∫£ bug fixes
// ================================================================
function updateJerkHint() {
    let jerkType = document.getElementById("jerkToggle").value;
    let hintEl = document.getElementById("jerkHint");
    if(jerkType==="frame") {
        let style = parseInt(document.getElementById("animStylePose").value)||2;
        let fps = parseFloat(document.getElementById("fpsPose").value)||24;
        let min = style*2; let max = Math.round((fps/24)*6)*style; if(max<min) max=min+style;
        hintEl.innerText = `${i18n[currentLang].dynHintFrames}${min} - ${max} frames`; hintEl.classList.remove("hidden");
    } else { hintEl.classList.add("hidden"); }
}

function togglePoseSettings() {
    let mode = document.getElementById("poseCalcMode").value;
    // [FIX P-14 partial] rowPoseSeconds visibility
    document.getElementById("rowPoseSeconds").classList.toggle("hidden", mode!=="seconds");
    let sub = document.getElementById("subPoseToggle").value;
    document.getElementById("rowSubPoseLogic").classList.toggle("hidden", sub!=="yes");
    if(sub==="yes") {
        document.getElementById("rowJerkiness").classList.add("hidden");
        document.getElementById("jerkToggle").value = "no";
        if(document.getElementById("jerkToggle").updateCustomUI) document.getElementById("jerkToggle").updateCustomUI();
    } else {
        document.getElementById("rowJerkiness").classList.remove("hidden");
    }
    let jerkType = document.getElementById("jerkToggle").value;
    let inputBlock = document.getElementById("jerkInputBlock");
    if(jerkType==="no") {
        inputBlock.classList.add("hidden");
    } else {
        inputBlock.classList.remove("hidden");
        let jInput = document.getElementById("jerkValue");
        // [FIX P-7] Reset jerk value properly when switching units
        if(jerkType==="sec") {
            jInput.step = "0.1";
            // Reset n·∫øu gi√° tr·ªã kh√¥ng h·ª£p l√Ω cho ƒë∆°n v·ªã gi√¢y (>5s l√† qu√° l·ªõn th∆∞·ªùng)
            let currentVal = parseFloat(jInput.value);
            if(isNaN(currentVal) || currentVal > 5 || currentVal < 0) jInput.value = 0.2;
        } else {
            jInput.step = "1";
            let currentVal = parseFloat(jInput.value);
            // Reset n·∫øu gi√° tr·ªã l√† s·ªë th·∫≠p ph√¢n r√µ r√†ng (d∆∞ t·ª´ ch·∫ø ƒë·ªô sec)
            if(isNaN(currentVal) || currentVal < 1 || (currentVal % 1 !== 0 && currentVal < 1)) jInput.value = 4;
            else jInput.value = Math.round(currentVal); // l√†m tr√≤n th√†nh s·ªë nguy√™n
        }
        updateJerkHint();
    }
}

function togglePoseActions() {
    let type = document.getElementById("focusTypePose").value;
    let charSel = document.getElementById("focusActionChar");
    let objSel = document.getElementById("focusActionObj");
    let charWrap = charSel.previousElementSibling;
    let objWrap = objSel.previousElementSibling;
    if(type==="char") {
        objSel.classList.add("hidden"); if(objWrap && objWrap.classList.contains("custom-select-wrapper")) objWrap.style.display="none";
        charSel.classList.remove("hidden"); if(charWrap && charWrap.classList.contains("custom-select-wrapper")) charWrap.style.display="";
    } else {
        charSel.classList.add("hidden"); if(charWrap && charWrap.classList.contains("custom-select-wrapper")) charWrap.style.display="none";
        objSel.classList.remove("hidden"); if(objWrap && objWrap.classList.contains("custom-select-wrapper")) objWrap.style.display="";
    }
}

function updatePoseEst() {
    let mode = document.getElementById("poseCalcMode").value;
    
    // [FIX P-4 + NOTE-P-1] Guard poseSeconds √¢m v√† c·∫≠p nh·∫≠t UI
    let secRaw = parseFloat(document.getElementById("poseSeconds").value);
    let sec;
    if(isNaN(secRaw) || secRaw <= 0) {
        sec = 1;
        document.getElementById("poseSeconds").value = 1; // [FIX NOTE-P-1] c·∫≠p nh·∫≠t ng∆∞·ª£c UI
    } else if(secRaw < 0.042) {
        sec = 0.042; // t·ªëi thi·ªÉu 1 frame t·∫°i 24fps
        document.getElementById("poseSeconds").value = 0.042;
    } else {
        sec = secRaw;
    }
    
    let fps = parseFloat(document.getElementById("fpsPose").value) || 24;
    let style = parseInt(document.getElementById("animStylePose").value) || 2;
    let pacing = document.getElementById("corePacingPose").value;
    let curve = document.getElementById("curveTypePose").value;
    let action = document.getElementById("focusTypePose").value==="char" ? document.getElementById("focusActionChar").value : document.getElementById("focusActionObj").value;
    let useSub = document.getElementById("subPoseToggle").value==="yes";
    let subRule = document.getElementById("subPoseLogic").value;
    let jerkType = document.getElementById("jerkToggle").value;
    let jerkVal = parseFloat(document.getElementById("jerkValue").value) || 0;
    let t = i18n[currentLang];
    
    let totalSec = mode==="seconds" ? sec : (Math.random() * 3.5 + 1.0);
    
    // [FIX UNKNOWN-1] Guard totalFrames = 0
    let totalFrames = Math.max(1, Math.round(totalSec * fps));
    
    let isTooLong = totalSec > 25;
    
    // [FIX UNKNOWN-15/16] Hi·ªÉn th·ªã warning thay v√¨ x√≥a tr·∫Øng khi custom invalid
    let isCustomValid = !(curve==='custom' && (mode!=='seconds' || sec < 3));
    if(!isCustomValid) {
        document.getElementById("poseOutput").innerHTML = `<div class="warning" style="text-align:left;">${t.warnCustomPose}</div>`;
        return;
    }

    let baseDensity = 1.0;
    if(pacing==="superslow") baseDensity=0.2; else if(pacing==="slowmo") baseDensity=0.4; else if(pacing==="slow") baseDensity=0.6;
    else if(pacing==="fast") baseDensity=1.5; else if(pacing==="superfast") baseDensity=2.0; else if(pacing==="timesplash") baseDensity=1.2;
    if(["fight","fly","break","run"].includes(action)) baseDensity*=1.4;
    if(["talk","scale"].includes(action)) baseDensity*=0.6;

    let totalDrawings = totalFrames / style;
    let mainPoseCount = Math.max(2, Math.round((totalDrawings * 0.2) * baseDensity));
    
    // [FIX P-2] Gi·ªõi h·∫°n random mode: ch·ªâ c·ªông th√™m t·ªëi ƒëa 1 pose, kh√¥ng random totalSec ƒë·ªôc l·∫≠p
    if(mode==="random" && Math.random()>0.5 && curve!=='custom') mainPoseCount += 1;
    
    // [FIX UNKNOWN-5] Hard cap mainPoseCount ƒë·ªÉ tr√°nh b√πng n·ªï
    let maxReasonablePoses = Math.min(24, Math.max(2, Math.floor(totalDrawings / 2)));
    mainPoseCount = Math.min(mainPoseCount, maxReasonablePoses);

    // [FIX P-3] isShortage d√πng mainPoseCount th·ª±c t·∫ø
    let isShortage = totalFrames < style * mainPoseCount;

    if(curve==='custom') updateCustomLUT('pose');

    let keys = []; let isClamped = false; let clampedTo = 0;
    for(let i=0; i<mainPoseCount; i++) {
        let x = i/(mainPoseCount-1 || 1);
        let p = 1 + getPacingCurve(x, curve, 'pose') * (totalFrames-1);
        let rawSnap = 1 + Math.round((p-1)/style)*style;
        keys.push(Math.max(1, Math.min(totalFrames, rawSnap)));
    }

    // [FIX BUG #1 Pose] missingPoses counter
    let rawKeyCount = keys.length;
    keys = [...new Set(keys)].sort((a,b)=>a-b);
    let missingPoses = rawKeyCount - keys.length;

    // [FIX BUG #2 Pose] isClamped d√πng secondLast logic
    if(keys.length > 0) {
        let lastKey = keys[keys.length-1];
        if(keys.length > 1) {
            let secondLast = keys[keys.length-2];
            if(lastKey===totalFrames && (totalFrames-secondLast)%style!==0) { isClamped=true; clampedTo=lastKey; }
            else if(lastKey!==totalFrames && (lastKey-1)%style!==0) { isClamped=true; clampedTo=lastKey; }
        }
    }

    let out = `‚âà ${totalSec.toFixed(2)} ${t.dynSec} | ${totalFrames} ${t.dynFrames}<br>`;
    out += `<div class="sub-result">${t.dynEstPoses}: ${keys.length} (KFs: ${keys.join(", ")})</div>`;

    if(missingPoses>0) out += `<div class="warning" style="text-align:left;margin-top:15px;color:#ffcc66;border-color:#ffcc66;">${t.dynMissingPose} <b>${missingPoses}</b>.</div>`;

    let boxHtml = ""; let subKeysList = [];
    let subWarnings = [];
    if(useSub) {
        boxHtml += `<b>${t.dynSubPose}:</b><br>`;
        for(let i=0; i<keys.length-1; i++) {
            let k1=keys[i], k2=keys[i+1];
            let subCount = subRule==="random" ? Math.floor(Math.random()*3)+1 : parseInt(subRule);
            let validSlots = [];
            for(let s=k1+style; s<k2; s+=style) validSlots.push(s);
            if(validSlots.length === 0) {
                // [FIX P-10 + UNKNOWN-6] C·∫£nh b√°o thay v√¨ im l·∫∑ng
                subWarnings.push(`[${k1}‚Üî${k2}]`);
            } else {
                let subs = []; let stepRatio = validSlots.length / subCount;
                for(let j=0; j<subCount; j++) {
                    let idx = Math.floor((j+0.5)*stepRatio);
                    if(idx<validSlots.length && !subs.includes(validSlots[idx])) {
                        subs.push(validSlots[idx]); subKeysList.push(validSlots[idx]);
                    }
                }
                // [FIX UNKNOWN-6] Th√¥ng b√°o n·∫øu √≠t sub h∆°n y√™u c·∫ßu
                if(subs.length < subCount && subs.length > 0) {
                    boxHtml += `‚Ä¢ ${t.dynSubBetween} [${k1}] ‚Üí [${k2}]: ${subs.join(", ")} <span style="color:#ffcc66;font-size:11px;">(${subs.length}/${subCount})</span><br>`;
                } else if(subs.length > 0) {
                    // [FIX P-15] D√πng i18n key dynSubBetween
                    boxHtml += `‚Ä¢ ${t.dynSubBetween} [${k1}] ‚Üí [${k2}]: ${subs.join(", ")}<br>`;
                }
            }
        }
        if(subWarnings.length > 0) {
            boxHtml += `<span style="color:#ffcc66;font-size:12px;">${t.dynSubNoSlot} ${subWarnings.join(", ")}</span><br>`;
        }
    }
    
    if(jerkType!=="no" && !useSub && jerkVal>0) {
        boxHtml += `<hr style="border-color:#1e3a5f;margin:10px 0;"><b>${t.dynHold}:</b><br>`;
        let actualJerkVal = jerkVal; let isCappedHold = false;
        if(jerkType==="sec") {
            let maxSec = totalSec*0.4; if(actualJerkVal>maxSec) { actualJerkVal=maxSec; isCappedHold=true; }
        } else {
            let maxFrames = Math.max(1, Math.floor(totalFrames*0.4));
            if(actualJerkVal>maxFrames) { actualJerkVal=maxFrames; isCappedHold=true; }
        }
        let unitText = jerkType==="sec" ? t.dynSec : t.dynFrames;
        actualJerkVal = jerkType==="sec" ? actualJerkVal.toFixed(2) : Math.round(actualJerkVal);
        boxHtml += `${t.dynHoldMsg1} <b>${actualJerkVal}</b> ${unitText} ${t.dynHoldMsg2}`;
        // [FIX P-15] dynHoldCapNote t·ª´ i18n
        if(isCappedHold) boxHtml += `<br><span style="color:#ffcc66;font-size:12px;">${t.dynHoldCapNote}</span>`;
    }

    if(boxHtml!=="") out += `<div class="box-result">${boxHtml}</div>`;
    if(isClamped||isShortage) out += `<div class="warning" style="text-align:left;margin-top:15px;">${t.dynClampWarn1}<b>${clampedTo||keys[keys.length-1]}</b>${t.dynClampWarn2}<b>${style}</b>${t.dynClampWarn3}</div>`;

    if(isTooLong) {
        out += `<div class="warning" style="text-align:left;margin-top:15px;color:#ff6b6b;border-color:#ff6b6b;">${t.dynGraphLimitWarn}</div>`;
    } else {
        out += `
        <div class="graph-title" style="margin-top:25px;margin-bottom:8px;"><span>${t.lblVisualGraph}</span><span class="tooltip" data-tip="${t.tipVisualGraph}">?</span></div>
        <div class="static-graph-wrapper"><canvas id="poseStaticGraph" class="graph-canvas"></canvas></div>
        <div class="graph-title" style="margin-top:25px;margin-bottom:8px;"><span>${t.lblDataGraph}</span><span class="tooltip" data-tip="${t.tipDataGraph}">?</span></div>
        <div class="graph-wrapper"><canvas id="poseGraph" class="graph-canvas"></canvas></div>
        <div class="graph-legend-box">
            <span style="color:#ffcc66">‚óè</span><span>${t.legendMainKey}</span>
            <span style="color:#00ccff;margin-left:15px;">‚óè</span><span>${t.legendSubKey}</span>
        </div>`;
    }
    document.getElementById("poseOutput").innerHTML = out;
    if(!isTooLong) {
        let allKeys = keys.concat([...new Set(subKeysList)]);
        let requiredWidth = Math.max(530, allKeys.length*40);
        renderStaticCurve("poseStaticGraph", curve, 'pose');
        renderGraph("poseGraph", keys, subKeysList, 1, totalFrames, requiredWidth);
    }
}

// ================================================================
// RENDER TAB
// ================================================================
function updateRender() {
    let frames = parseFloat(document.getElementById("totalFrames").value);
    let pFrame = parseFloat(document.getElementById("renderPerFrame").value);
    if(isNaN(frames)||isNaN(pFrame)||frames<0||pFrame<0) { document.getElementById("renderOutput").innerText = "‚Äî"; return; }
    let tot = frames*pFrame;
    let d = Math.floor(tot/86400), h = Math.floor((tot%86400)/3600), m = Math.floor((tot%3600)/60), s = Math.floor(tot%60);
    document.getElementById("renderOutput").innerText = (d>0?d+(currentLang==="vi"?" ng√†y ":"d "):"") + `${h}h ${m}m ${s}s`;
}

// ================================================================
// LANGUAGE + I18N
// ================================================================
function changeLang(lang) {
    currentLang = lang; let t = i18n[lang];
    document.querySelectorAll('[data-i18n]').forEach(el => { el.innerText = t[el.getAttribute('data-i18n')]; });
    for(let id in t) {
        let el = document.getElementById(id);
        if(el) {
            if(el.classList.contains("tooltip")) { el.dataset.tip = t[id]; }
            else if(el.tagName==="INPUT" && el.hasAttribute("data-i18n-ph")) { let pKey = el.getAttribute("data-i18n-ph"); if(t[pKey]) el.placeholder = t[pKey]; }
            else { el.innerText = t[id]; }
        }
    }
    let sF = document.getElementById("startFrame"); if(sF) sF.placeholder = t.phStartFrame;
    let eF = document.getElementById("endFrame"); if(eF) eF.placeholder = t.phEndFrame;
    
    // [FIX P-14] changeLang ph·∫£i g·ªçi togglePoseSettings ƒë·ªÉ ƒë·ªìng b·ªô visibility rows
    togglePoseSettings();
    toggleAnimePoseInput();
    
    updateConvert(); updateAnime(); updatePoseEst(); updateRender(); updateAllCustomSelects(); updateJerkHint();
}

// ================================================================
// CUSTOM DROPDOWNS
// ================================================================
function initCustomSelects() {
    document.querySelectorAll("select").forEach(sel => {
        if(sel.nextElementSibling && sel.nextElementSibling.classList.contains("custom-select-options")) return;
        const wrap = document.createElement("div"); wrap.className = "custom-select-wrapper";
        sel.parentNode.insertBefore(wrap, sel); wrap.appendChild(sel);
        const trig = document.createElement("div"); trig.className = "custom-select-trigger";
        const opts = document.createElement("div"); opts.className = "custom-select-options";
        wrap.appendChild(trig); wrap.appendChild(opts);
        function updateUI() { if(sel.selectedIndex>=0) trig.innerHTML = `<span>${sel.options[sel.selectedIndex].text}</span><div class="arrow"></div>`; }
        function buildOpts() {
            opts.innerHTML = "";
            Array.from(sel.options).forEach((o,i) => {
                const od = document.createElement("div"); od.className = "custom-select-option";
                if(i===sel.selectedIndex) od.classList.add("selected"); od.innerText = o.text;
                od.addEventListener("click", e => { e.stopPropagation(); sel.selectedIndex=i; sel.dispatchEvent(new Event("change")); updateUI(); opts.classList.remove("show"); trig.classList.remove("active"); });
                opts.appendChild(od);
            });
        }
        trig.addEventListener("click", e => {
            e.stopPropagation(); const isS = opts.classList.contains("show");
            document.querySelectorAll(".custom-select-options").forEach(el=>el.classList.remove("show"));
            document.querySelectorAll(".custom-select-trigger").forEach(el=>el.classList.remove("active"));
            if(!isS) { buildOpts(); opts.classList.add("show"); trig.classList.add("active"); }
        });
        updateUI(); sel.style.display="none"; sel.updateCustomUI=updateUI;
    });
    document.addEventListener("click", ()=>{
        document.querySelectorAll(".custom-select-options").forEach(el=>el.classList.remove("show"));
        document.querySelectorAll(".custom-select-trigger").forEach(el=>el.classList.remove("active"));
    });
}

function updateAllCustomSelects() { document.querySelectorAll("select").forEach(s=>{ if(s.updateCustomUI) s.updateCustomUI(); }); }

// ================================================================
// INIT
// ================================================================
window.addEventListener("DOMContentLoaded", ()=>{
    updateCustomLUT('anime'); updateCustomLUT('pose');
    initCustomSelects(); changeLang('vi');
    togglePoseActions(); togglePoseSettings(); toggleAnimePoseInput();
});
</script>
</body>
</html>
