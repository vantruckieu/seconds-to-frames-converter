<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<title id="title">Timing & Render Tool</title>

<style>
@import url('https://fonts.googleapis.com/css2?family=Be+Vietnam+Pro:wght@400;500;700&display=swap');

body {
    color-scheme: dark; 
    background: radial-gradient(circle at 20% 20%, #0f1c2e, #050b18 70%);
    font-family: 'Google Sans', 'Be Vietnam Pro', 'Segoe UI', sans-serif;
    color: #e6f3ff;
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 0;
    padding: 40px 20px 80px 20px;
    min-height: 100vh;
    box-sizing: border-box;
}

h1 {
    margin: 0 0 10px 0;
    font-size: 28px;
    text-align: center;
    color: #00ccff;
    text-shadow: 0 0 20px rgba(0,200,255,0.6);
}

.intro {
    text-align: center;
    max-width: 600px;
    margin-bottom: 30px;
    opacity: 0.8;
    line-height: 1.5;
}

.container {
    background: linear-gradient(145deg, #0e1624, #111c2f);
    padding: 35px;
    border-radius: 20px;
    width: 600px; 
    box-shadow: 0 0 40px rgba(0,140,255,0.25), inset 0 0 60px rgba(0,80,160,0.15);
    border: 1px solid rgba(0,180,255,0.2);
}

.tabs {
    display: flex;
    gap: 8px;
    margin-bottom: 25px;
}

.tabs button {
    flex: 1;
    padding: 10px 5px;
    background: #0c1626;
    border: 1px solid #1b3555;
    border-radius: 10px;
    color: #7fbfff;
    cursor: pointer;
    transition: 0.3s;
    font-weight: 500;
    font-family: inherit;
    font-size: 13px;
}

.tabs button:hover { background: #11233d; box-shadow: 0 0 12px rgba(0,170,255,0.4); }
.tabs button.active { background: linear-gradient(90deg,#0066ff,#00ccff); color: white; border-color: #00ccff; box-shadow: 0 0 20px rgba(0,200,255,0.6); }

.tab-desc {
    font-size: 13px;
    color: #9ed8ff;
    background: rgba(0, 150, 255, 0.08);
    border-left: 3px solid #00ccff;
    padding: 10px 15px;
    margin-bottom: 22px;
    border-radius: 0 8px 8px 0;
    line-height: 1.5;
}

.row { margin-bottom: 18px; }

label {
    display: flex;
    align-items: center;
    margin-bottom: 6px;
    font-size: 14px;
    opacity: 0.85;
    color: #9ed8ff;
}

input {
    width: 100%;
    padding: 12px;
    font-size: 15px;
    font-family: inherit;
    background: #0a1422;
    border: 1px solid #1e3a5f;
    border-radius: 10px;
    color: #e6f3ff;
    transition: 0.3s;
    box-sizing: border-box;
}

input:focus { outline: none; border-color: #00ccff; box-shadow: 0 0 12px rgba(0,200,255,0.5); }

/* CUSTOM DROPDOWN */
.custom-select-wrapper { position: relative; width: 100%; }
.custom-select-wrapper:has(select.hidden) { display: none !important; }
.input-group .custom-select-wrapper { flex: 1; }

.custom-select-trigger {
    width: 100%; padding: 12px; font-size: 14px; font-family: inherit;
    background: #0a1422; border: 1px solid #1e3a5f; border-radius: 10px;
    color: #e6f3ff; cursor: pointer; display: flex; justify-content: space-between;
    align-items: center; transition: 0.3s; box-sizing: border-box; user-select: none;
}
.custom-select-trigger:hover, .custom-select-trigger.active { border-color: #00ccff; box-shadow: 0 0 12px rgba(0,200,255,0.5); }
.custom-select-trigger .arrow {
    width: 16px; height: 16px;
    background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%239ed8ff' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
    background-size: contain; background-repeat: no-repeat; background-position: center; transition: transform 0.3s;
}
.custom-select-trigger.active .arrow { transform: rotate(180deg); }

.custom-select-options {
    position: absolute; top: calc(100% + 5px); left: 0; right: 0; background: #0a1422;
    border: 1px solid #1e3a5f; border-radius: 10px; box-shadow: 0 5px 20px rgba(0,0,0,0.6);
    z-index: 99; opacity: 0; visibility: hidden; transform: translateY(-10px);
    transition: all 0.2s ease-out; overflow-y: auto; max-height: 220px;
}
.custom-select-options.show { opacity: 1; visibility: visible; transform: translateY(0); }
.custom-select-option { padding: 12px; font-size: 13px; cursor: pointer; transition: 0.2s; color: #e6f3ff; border-bottom: 1px solid rgba(30, 58, 95, 0.4); }
.custom-select-option:last-child { border-bottom: none; }
.custom-select-option:hover, .custom-select-option.selected { background: #11233d; color: #00ccff; }

.input-group { display: flex; gap: 10px; }
.input-group input { flex: 1; }
.fps-presets { display: flex; gap: 8px; margin-top: 8px; }
.fps-presets button {
    flex: 1; padding: 6px; background: #0e1c2f; border: 1px solid #1f4068;
    border-radius: 8px; color: #66ccff; cursor: pointer; font-size: 13px; transition: 0.2s;
}
.fps-presets button:hover { background: #133a66; box-shadow: 0 0 8px rgba(0,200,255,0.6); }

/* Results */
.result { margin-top: 25px; font-size: 24px; font-weight: bold; color: #00ccff; text-align: center; text-shadow: 0 0 15px rgba(0,200,255,0.6); }
.sub-result { display: block; font-size: 14px; font-weight: normal; color: #9ed8ff; margin-top: 8px; opacity: 0.9; line-height: 1.5; }
.box-result { font-size: 14px; color: #cceeff; background: rgba(0, 102, 255, 0.1); border: 1px dashed #0066ff; padding: 12px; border-radius: 8px; margin-top: 15px; text-align: left; line-height: 1.6;}

/* Tooltip & Warning */
.tooltip {
    display: inline-flex; align-items: center; justify-content: center; width: 16px; height: 16px;
    background: rgba(0, 204, 255, 0.1); border: 1px solid #00ccff; border-radius: 50%;
    color: #00ccff; font-size: 11px; font-weight: bold; cursor: help; position: relative; margin-left: 8px; transition: 0.3s;
}
.tooltip:hover { background: #00ccff; color: #0a1422; box-shadow: 0 0 10px rgba(0, 204, 255, 0.6); }
.tooltip:hover::after {
    content: attr(data-tip); position: absolute; bottom: 150%; left: 50%; transform: translateX(-50%);
    background: #02111f; padding: 10px 14px; font-size: 12px; font-weight: normal; border-radius: 8px;
    width: 240px;
    color: #cceeff; box-shadow: 0 4px 15px rgba(0,170,255,0.6);
    border: 1px solid rgba(0, 204, 255, 0.4); 
    z-index: 9999; 
    text-align: left; white-space: pre-wrap; line-height: 1.5; word-wrap: break-word;
}

.warning { margin-top: 15px; font-size: 13px; color: #ffcc66; background: rgba(255, 204, 102, 0.1); padding: 10px; border-radius: 8px; border: 1px solid rgba(255, 204, 102, 0.3); line-height: 1.4;}
.hidden { display: none !important; }

/* Canvas Graph Styling */
.graph-title {
    font-size: 14px;
    font-weight: 600;
    color: #9ed8ff;
    margin-top: 25px;
    margin-bottom: 5px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
}
.static-graph-wrapper {
    background: rgba(10, 20, 34, 0.4);
    border-radius: 10px;
    border: 1px dashed #1e3a5f;
    width: 100%;
    margin-top: 5px;
    box-sizing: border-box;
    display: flex;
    justify-content: center;
}
.graph-wrapper {
    margin-top: 5px;
    background: rgba(10, 20, 34, 0.6);
    border-radius: 10px;
    border: 1px solid #1e3a5f;
    width: 100%;
    overflow-x: auto;
    box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.5);
}

.graph-wrapper::-webkit-scrollbar { height: 8px; }
.graph-wrapper::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); border-radius: 10px; }
.graph-wrapper::-webkit-scrollbar-thumb { background: #1e3a5f; border-radius: 10px; }
.graph-wrapper::-webkit-scrollbar-thumb:hover { background: #00ccff; }

.graph-canvas {
    display: block;
    background: transparent;
    border: none;
    box-shadow: none;
}

footer { margin-top: 40px; font-size: 14px; color: #66ccff; opacity: 0.8; display: flex; align-items: center; justify-content: center; gap: 10px; }
footer .custom-select-wrapper { width: auto; min-width: 110px; }
footer .custom-select-trigger { padding: 6px 12px; font-size: 14px; border-radius: 6px; }

.note-text { font-size: 12px; color: #66ccff; margin-top: 4px; display: block; opacity: 0.8; }
</style>
</head>

<body>

<h1 id="mainTitle">Timing & Render Tool</h1>
<div class="intro" id="introText">C√¥ng c·ª• ƒëa nƒÉng h·ªó tr·ª£ Animation Timing, T√≠nh to√°n Frame v√† Render.</div>

<div class="container">
    <div class="tabs">
        <button id="tabConvert" class="active" onclick="switchTab('convert')">Time / Frame</button>
        <button id="tabAnime" onclick="switchTab('anime')">Anime, Toon Frame</button>
        <button id="tabPose" onclick="switchTab('pose')">D·ª± t√≠nh Pose</button>
        <button id="tabRender" onclick="switchTab('render')">Render Time</button>
    </div>

    <div id="convertMode">
        <div class="tab-desc" id="descConvert">Chuy·ªÉn ƒë·ªïi qua l·∫°i gi·ªØa th·ªùi l∆∞·ª£ng (Gi√¢y/Ph√∫t/Gi·ªù) v√† S·ªë khung h√¨nh (Frames) theo t·ªëc ƒë·ªô chu·∫©n.</div>
        <div class="row">
            <label>
                <span id="lblMode">Lo·∫°i t√≠nh</span>
                <span class="tooltip" id="tipMode" data-tip="?">?</span>
            </label>
            <select id="mode" onchange="updateConvert()">
                <option id="optF2T" value="f2t">Frame ‚Üí Time</option>
                <option id="optT2F" value="t2f">Time ‚Üí Frame</option>
            </select>
        </div>
        <div class="row">
            <label>
                <span id="lblFPS_conv">FPS</span>
                <span class="tooltip" id="tipFPS_conv" data-tip="?">?</span>
            </label>
            <input type="number" id="fps" step="0.001" value="24" min="1" oninput="updateConvert()">
            <div class="fps-presets">
                <button onclick="setField('fps', 12); updateConvert()">12</button>
                <button onclick="setField('fps', 24); updateConvert()">24</button>
                <button onclick="setField('fps', 30); updateConvert()">30</button>
                <button onclick="setField('fps', 60); updateConvert()">60</button>
            </div>
        </div>
        <div class="row">
            <label>
                <span id="lblInput">S·ªë khung h√¨nh/th·ªùi gian</span>
                <span class="tooltip" id="tipInput" data-tip="?">?</span>
            </label>
            <div class="input-group">
                <input type="number" id="inputValue" min="0" oninput="updateConvert()">
                <select id="timeUnit" class="hidden" onchange="updateConvert()">
                    <option id="optSec" value="1">Gi√¢y</option>
                    <option id="optMin" value="60">Ph√∫t</option>
                    <option id="optHour" value="3600">Gi·ªù</option>
                </select>
            </div>
        </div>
        <div class="result" id="convertOutput">‚Äî</div>
    </div>

    <div id="animeMode" class="hidden">
        <div class="tab-desc" id="descAnime">Ph√¢n b·ªï kho·∫£ng c√°ch c√°c Keyframe theo quy t·∫Øc Animation (On 1s, 2s, 3s) v√† n·ªôi suy nh·ªãp ƒë·ªô c·∫£nh.</div>
        <div class="row">
            <label>
                <span id="lblAnimStyle">Ki·ªÉu di·ªÖn ho·∫°t</span>
                <span class="tooltip" id="tipAnimStyle" data-tip="?">?</span>
            </label>
            <select id="animStyle" onchange="updateAnime()">
                <option id="optOn1s" value="1">On 1s (M∆∞·ª£t / H√†nh ƒë·ªông)</option>
                <option id="optOn2s" value="2" selected>On 2s (Chu·∫©n Anime)</option>
                <option id="optOn3s" value="3">On 3s (Tƒ©nh / Ch·∫≠m)</option>
            </select>
        </div>
        <div class="row">
            <label>
                <span id="lblFPS_anime">FPS g·ªëc</span>
                <span class="tooltip" id="tipFPS_anime" data-tip="?">?</span>
            </label>
            <input type="number" id="fpsAnime" value="24" min="1" oninput="updateAnime()">
            <div class="fps-presets">
                <button onclick="setField('fpsAnime', 12); updateAnime()">12</button>
                <button onclick="setField('fpsAnime', 24); updateAnime()">24</button>
                <button onclick="setField('fpsAnime', 30); updateAnime()">30</button>
                <button onclick="setField('fpsAnime', 60); updateAnime()">60</button>
            </div>
        </div>
        <div class="row">
            <label>
                <span id="lblCorePacingAnime">Nh·ªãp t√¢m ƒëi·ªÉm</span>
                <span class="tooltip" id="tipCorePacingAnime" data-tip="?">?</span>
            </label>
            <select id="corePacingAnime" onchange="updateAnime()">
                <option id="optCpSuperSlowA" value="superslow">Super Slow</option>
                <option id="optCpSlowmoA" value="slowmo">Slow Motion</option>
                <option id="optCpSlowA" value="slow">Ch·∫≠m</option>
                <option id="optCpNormalA" value="normal" selected>B√¨nh th∆∞·ªùng</option>
                <option id="optCpFastA" value="fast">Nhanh</option>
                <option id="optCpSuperFastA" value="superfast">C·ª±c nhanh</option>
                <option id="optCpTimeSplashA" value="timesplash">Time Splash</option>
            </select>
        </div>
        <div class="row">
            <label>
                <span id="lblCurveTypeAnime">Lo·∫°i ƒë·ªì th·ªã (Ph√¢n b·ªï)</span>
                <span class="tooltip" id="tipCurveTypeAnime" data-tip="?">?</span>
            </label>
            <select id="curveTypeAnime" onchange="updateAnime()">
                <option id="optCvNoneA" value="linear">Kh√¥ng (ƒê·ªÅu)</option>
                <option id="optCvEaseOutA" value="ease_out">ƒê·ªì th·ªã xu·ªëng (Ch·∫≠m d·∫ßn)</option>
                <option id="optCvEaseInA" value="ease_in">ƒê·ªì th·ªã l√™n (Nhanh d·∫ßn)</option>
                <option id="optCvClimaxA" value="climax">ƒêi·ªÉm cao tr√†o (Nhanh gi·ªØa)</option>
                <option id="optCvLowPointA" value="low_point">ƒêi·ªÉm tr·∫ßm (Ch·∫≠m gi·ªØa)</option>
                <option id="optCvWaveA" value="wave">S√≥ng (Nhanh ch·∫≠m xen k·∫Ω)</option>
            </select>
        </div>
        <div class="row">
            <label>
                <span id="lblFocus">T√¢m ƒëi·ªÉm & Tr·∫°ng th√°i</span>
                <span class="tooltip" id="tipFocus" data-tip="?">?</span>
            </label>
            <div class="input-group">
                <select id="focusTarget" onchange="updateAnime()">
                    <option id="optFocScene" value="scene">C·∫£nh</option>
                    <option id="optFocChar" value="char">Nh√¢n v·∫≠t/V·∫≠t th·ªÉ</option>
                </select>
                <select id="focusState" onchange="toggleAnimePoseInput(); updateAnime()">
                    <option id="optStateStatic" value="static">Tƒ©nh</option>
                    <option id="optStateDynamic" value="dynamic" selected>ƒê·ªông</option>
                </select>
            </div>
        </div>
        <div class="row" id="poseRow">
            <label>
                <span id="lblPose">S·ªë Pose (Keyframes ch√≠nh)</span>
                <span class="tooltip" id="tipPose" data-tip="?">?</span>
            </label>
            <input type="number" id="poseCount" value="5" min="1" oninput="updateAnime()">
        </div>
        <div class="row">
            <label>
                <span id="lblFrameRange">Frame B·∫Øt ƒë·∫ßu - K·∫øt th√∫c</span>
                <span class="tooltip" id="tipFrameRange" data-tip="?">?</span>
            </label>
            <div class="input-group">
                <input type="number" id="startFrame" data-i18n-ph="phStartFrame" placeholder="B·∫Øt ƒë·∫ßu (vd: 1)" oninput="updateAnime()">
                <input type="number" id="endFrame" data-i18n-ph="phEndFrame" placeholder="K·∫øt th√∫c (vd: 100)" oninput="updateAnime()">
            </div>
        </div>
        <div class="row">
            <label>
                <span id="lblCalcLogic">Logic t√≠nh to√°n</span>
                <span class="tooltip" id="tipCalcLogic" data-tip="?">?</span>
            </label>
            <select id="calcLogic" onchange="updateAnime()">
                <option id="optLogicStrict" value="strict">To√°n h·ªçc nghi√™m ng·∫∑t</option>
                <option id="optLogicRandom" value="random">X√°c su·∫•t ng·∫´u nhi√™n</option>
            </select>
        </div>
        <div class="result" id="animeOutput">‚Äî</div>
        <div class="warning" id="warnMathModelAnime">‚ö† Ch·ªâ d√πng ƒë·ªÉ tham kh·∫£o. M√¥ h√¨nh d·ª±a tr√™n n·ªôi suy to√°n h·ªçc v√† ƒë·ªì th·ªã ng·∫´u nhi√™n.</div>
    </div>

    <div id="poseMode" class="hidden">
        <div class="tab-desc" id="descPose">T·ª± ƒë·ªông ∆∞·ªõc t√≠nh s·ªë l∆∞·ª£ng Pose ch√≠nh v√† Pose ph·ª• tr·ª£ (In-betweens) ph·ª• thu·ªôc v√†o h√†nh ƒë·ªông c·ª• th·ªÉ v√† th·ªùi l∆∞·ª£ng.</div>
        <div class="row">
            <label>
                <span id="lblPoseCalcMode">C√°ch t√≠nh to√°n</span>
                <span class="tooltip" id="tipPoseCalcMode" data-tip="?">?</span>
            </label>
            <select id="poseCalcMode" onchange="togglePoseSettings(); updatePoseEst()">
                <option id="optPcalcRandom" value="random">X√°c su·∫•t ng·∫´u nhi√™n</option>
                <option id="optPcalcSeconds" value="seconds">Theo s·ªë gi√¢y c·∫£nh</option>
            </select>
        </div>
        <div class="row hidden" id="rowPoseSeconds">
            <label>
                <span id="lblPoseSeconds">Nh·∫≠p s·ªë gi√¢y c·∫£nh</span>
                <span class="tooltip" id="tipPoseSeconds" data-tip="?">?</span>
            </label>
            <input type="number" id="poseSeconds" value="3" min="0.1" step="0.1" oninput="updatePoseEst()">
        </div>
        <div class="row">
            <label>
                <span id="lblFPS_pose">FPS g·ªëc</span>
                <span class="tooltip" id="tipFPS_pose" data-tip="?">?</span>
            </label>
            <input type="number" id="fpsPose" value="24" min="1" oninput="updatePoseEst(); updateJerkHint()">
            <div class="fps-presets">
                <button onclick="setField('fpsPose', 12); updatePoseEst(); updateJerkHint()">12</button>
                <button onclick="setField('fpsPose', 24); updatePoseEst(); updateJerkHint()">24</button>
                <button onclick="setField('fpsPose', 30); updatePoseEst(); updateJerkHint()">30</button>
                <button onclick="setField('fpsPose', 60); updatePoseEst(); updateJerkHint()">60</button>
            </div>
        </div>
        <div class="row">
            <label>
                <span id="lblAnimStylePose">Lo·∫°i di·ªÖn ho·∫°t</span>
                <span class="tooltip" id="tipAnimStylePose" data-tip="?">?</span>
            </label>
            <select id="animStylePose" onchange="updatePoseEst(); updateJerkHint()">
                <option id="optPO1" value="1">On 1s</option>
                <option id="optPO2" value="2" selected>On 2s</option>
                <option id="optPO3" value="3">On 3s</option>
            </select>
        </div>
        <div class="row">
            <label>
                <span id="lblFocusTypePose">Lo·∫°i t√¢m ƒëi·ªÉm</span>
                <span class="tooltip" id="tipFocusTypePose" data-tip="?">?</span>
            </label>
            <select id="focusTypePose" onchange="togglePoseActions(); updatePoseEst()">
                <option id="optFocCharP" value="char">Nh√¢n v·∫≠t</option>
                <option id="optFocObjP" value="obj">V·∫≠t th·ªÉ</option>
            </select>
        </div>
        <div class="row">
            <label>
                <span id="lblFocusActionPose">H√†nh ƒë·ªông c·ª• th·ªÉ</span>
                <span class="tooltip" id="tipFocusActionPose" data-tip="?">?</span>
            </label>
            <select id="focusActionChar" class="" onchange="updatePoseEst()">
                <option value="talk" id="actTalk">N√≥i chuy·ªán</option>
                <option value="walk" id="actWalk">ƒêi b·ªô</option>
                <option value="run" id="actRun">Ch·∫°y</option>
                <option value="fight" id="actFight">ƒê√°nh nhau</option>
                <option value="other" id="actOtherC">H√†nh ƒë·ªông kh√°c</option>
            </select>
            <select id="focusActionObj" class="hidden" onchange="updatePoseEst()">
                <option value="fly" id="actFly">Bay</option>
                <option value="fall" id="actFall">R∆°i</option>
                <option value="break" id="actBreak">V·ª°/G√£y</option>
                <option value="bounce" id="actBounce">N·∫£y l√™n/xu·ªëng</option>
                <option value="scale" id="actScale">Ph√≥ng to/Thu nh·ªè</option>
                <option value="other" id="actOtherO">H√†nh ƒë·ªông kh√°c</option>
            </select>
        </div>
        <div class="row">
            <label>
                <span id="lblCorePacingPose">Nh·ªãp t√¢m ƒëi·ªÉm</span>
                <span class="tooltip" id="tipCorePacingPose" data-tip="?">?</span>
            </label>
            <select id="corePacingPose" onchange="updatePoseEst()">
                <option id="optCpSuperSlowP" value="superslow">Super Slow</option>
                <option id="optCpSlowmoP" value="slowmo">Slow Motion</option>
                <option id="optCpSlowP" value="slow">Ch·∫≠m</option>
                <option id="optCpNormalP" value="normal" selected>B√¨nh th∆∞·ªùng</option>
                <option id="optCpFastP" value="fast">Nhanh</option>
                <option id="optCpSuperFastP" value="superfast">C·ª±c nhanh</option>
                <option id="optCpTimeSplashP" value="timesplash">Time Splash</option>
            </select>
        </div>
        <div class="row">
            <label>
                <span id="lblCurveTypePose">Lo·∫°i ƒë·ªì th·ªã</span>
                <span class="tooltip" id="tipCurveTypePose" data-tip="?">?</span>
            </label>
            <select id="curveTypePose" onchange="updatePoseEst()">
                <option id="optCvNoneP" value="linear">Kh√¥ng</option>
                <option id="optCvEaseOutP" value="ease_out">ƒê·ªì th·ªã xu·ªëng</option>
                <option id="optCvEaseInP" value="ease_in">ƒê·ªì th·ªã l√™n</option>
                <option id="optCvClimaxP" value="climax">ƒêi·ªÉm cao tr√†o</option>
                <option id="optCvLowPointP" value="low_point">ƒêi·ªÉm tr·∫ßm</option>
                <option id="optCvWaveP" value="wave">S√≥ng (Cao/th·∫•p c·∫°nh nhau)</option>
            </select>
        </div>
        <div class="row">
            <label>
                <span id="lblSubPose">Th√™m Pose ph·ª• tr·ª£ (In-betweens)</span>
                <span class="tooltip" id="tipSubPose" data-tip="?">?</span>
            </label>
            <select id="subPoseToggle" onchange="togglePoseSettings(); updatePoseEst()">
                <option id="optNo" value="no">Kh√¥ng</option>
                <option id="optYes" value="yes">C√≥</option>
            </select>
        </div>
        <div class="row hidden" id="rowSubPoseLogic">
            <label>
                <span id="lblSubPoseLogic">Quy t·∫Øc Pose ph·ª• tr·ª£</span>
                <span class="tooltip" id="tipSubPoseLogic" data-tip="?">?</span>
            </label>
            <select id="subPoseLogic" onchange="updatePoseEst()">
                <option id="optSpRandom" value="random">X√°c su·∫•t ng·∫´u nhi√™n</option>
                <option value="1">1 Pose ph·ª•</option>
                <option value="2">2 Pose ph·ª•</option>
                <option value="3">3 Pose ph·ª•</option>
                <option value="4">4 Pose ph·ª•</option>
            </select>
        </div>
        
        <div class="row" id="rowJerkiness">
            <label>
                <span id="lblJerkiness">ƒê·ªô gi·∫≠t - kh·ª±ng (Stutter/Hold)</span>
                <span class="tooltip" id="tipJerkiness" data-tip="?">?</span>
            </label>
            <select id="jerkToggle" onchange="togglePoseSettings(); updatePoseEst()">
                <option id="optJerkNo" value="no">Kh√¥ng</option>
                <option id="optJerkSec" value="sec">Theo Gi√¢y</option>
                <option id="optJerkFrame" value="frame">Theo Frame</option>
            </select>
            
            <div id="jerkInputBlock" class="hidden" style="margin-top: 10px;">
                <input type="number" id="jerkValue" value="2" min="0" step="0.1" oninput="updatePoseEst()">
                <span id="jerkHint" class="note-text hidden"></span>
            </div>
        </div>
        
        <div class="result" id="poseOutput">‚Äî</div>
        <div class="warning" id="warnMathModelPose">‚ö† Ch·ªâ ƒë·ªÉ tham kh·∫£o, t√≠nh to√°n theo m√¥ h√¨nh to√°n h·ªçc v√† x√°c su·∫•t ng·∫´u nhi√™n.</div>
    </div>

    <div id="renderMode" class="hidden">
        <div class="tab-desc" id="descRender">∆Ø·ªõc t√≠nh t·ªïng th·ªùi gian xu·∫•t file (Render) c·ªßa to√†n b·ªô d·ª± √°n d·ª±a tr√™n th·ªùi gian ch·∫°y 1 khung h√¨nh.</div>
        <div class="row">
            <label>
                <span id="lblTotalFrames">T·ªïng s·ªë frame</span>
                <span class="tooltip" id="tipTotalFrames" data-tip="?">?</span>
            </label>
            <input type="number" id="totalFrames" min="0" oninput="updateRender()">
        </div>
        <div class="row">
            <label>
                <span id="lblRenderPerFrame">Th·ªùi gian render 1 frame (gi√¢y)</span>
                <span class="tooltip" id="tipRenderPerFrame" data-tip="?">?</span>
            </label>
            <input type="number" id="renderPerFrame" step="0.01" min="0" oninput="updateRender()">
        </div>
        <div class="result" id="renderOutput">‚Äî</div>
        <div class="warning" id="warningTextRender">‚ö† Ch·ªâ d√πng ƒë·ªÉ tham kh·∫£o. M·∫≠t ƒë·ªô chi ti·∫øt c·∫£nh th·ª±c t·∫ø s·∫Ω l√†m ƒë·ªïi th·ªùi gian.</div>
    </div>
</div>

<footer>
    <span id="lblLanguage">Ng√¥n ng·ªØ:</span>
    <select onchange="changeLang(this.value)">
        <option value="vi">üáªüá≥ VI</option>
        <option value="en">üá¨üáß EN</option>
    </select>
</footer>

<script>
let currentLang = "vi";

const i18n = {
    vi: {
        introText: "C√¥ng c·ª• ƒëa nƒÉng h·ªó tr·ª£ Animation Timing, T√≠nh to√°n Frame v√† Render.",
        tabConvert: "Time / Frame", tabAnime: "Anime, Toon Frame", tabPose: "D·ª± t√≠nh Pose", tabRender: "Render Time",
        
        descConvert: "C√¥ng c·ª• chuy·ªÉn ƒë·ªïi qua l·∫°i gi·ªØa th·ªùi l∆∞·ª£ng (Gi√¢y/Ph√∫t/Gi·ªù) v√† S·ªë khung h√¨nh (Frames) theo t·ªëc ƒë·ªô chu·∫©n.",
        descAnime: "Ph√¢n b·ªï kho·∫£ng c√°ch c√°c Keyframe theo quy t·∫Øc Animation (On 1s, 2s, 3s) v√† n·ªôi suy nh·ªãp ƒë·ªô c·∫£nh.",
        descPose: "T·ª± ƒë·ªông ∆∞·ªõc t√≠nh s·ªë l∆∞·ª£ng Pose ch√≠nh v√† Pose ph·ª• tr·ª£ (In-betweens) ph·ª• thu·ªôc v√†o h√†nh ƒë·ªông c·ª• th·ªÉ v√† th·ªùi l∆∞·ª£ng.",
        descRender: "∆Ø·ªõc t√≠nh t·ªïng th·ªùi gian xu·∫•t file (Render) c·ªßa to√†n b·ªô d·ª± √°n d·ª±a tr√™n th·ªùi gian ch·∫°y 1 khung h√¨nh.",

        tipMode: "Ch·ªçn lo·∫°i chuy·ªÉn ƒë·ªïi:\n‚Ä¢ Frame ‚Üí Time: ƒê·ªïi t·ª´ Khung h√¨nh sang Th·ªùi gian.\n‚Ä¢ Time ‚Üí Frame: ƒê·ªïi t·ª´ Th·ªùi gian sang Khung h√¨nh.",
        tipFPS_conv: "FPS (Frames Per Second) l√† s·ªë khung h√¨nh tr√™n 1 gi√¢y.\n‚Ä¢ ƒêi·ªán ·∫£nh: 24 fps\n‚Ä¢ Game/TV: 30 ho·∫∑c 60 fps.",
        tipInput: "Nh·∫≠p gi√° tr·ªã c·∫ßn t√≠nh to√°n (t·ªïng s·ªë frame ho·∫∑c s·ªë gi√¢y/ph√∫t).",
        
        tipAnimStyle: "Quy ƒë·ªãnh s·ªë b·∫£n v·∫Ω tr√™n gi√¢y:\n‚Ä¢ On 1s: 24 h√¨nh/gi√¢y (M∆∞·ª£t, Action).\n‚Ä¢ On 2s: 12 h√¨nh/gi√¢y (Chu·∫©n Anime).\n‚Ä¢ On 3s: 8 h√¨nh/gi√¢y (Ch·∫≠m, Tƒ©nh).",
        tipFPS_anime: "Khung h√¨nh ti√™u chu·∫©n c·ªßa to√†n b·ªô Project (Th∆∞·ªùng l√† 24).",
        tipCorePacingAnime: "T·ªëc ƒë·ªô di·ªÖn ho·∫°t t·ªïng th·ªÉ c·ªßa c·∫£nh ƒë·ªÉ h·ªá th·ªëng ph√¢n b·ªï Keyframe.",
        tipCurveTypeAnime: "ƒê∆∞·ªùng cong gia t·ªëc (Easing):\n‚Ä¢ Xu·ªëng: Th∆∞a d·∫ßn v·ªÅ sau.\n‚Ä¢ L√™n: D√†y d·∫ßn v·ªÅ sau.\n‚Ä¢ Cao tr√†o: D√†y ƒë·∫∑c ·ªü gi·ªØa.",
        tipFocus: "Tr·∫°ng th√°i c·ªßa ƒë·ªëi t∆∞·ª£ng ƒëang ƒê·ªông (c√≥ di chuy·ªÉn) hay Tƒ©nh (ƒë·ª©ng im).",
        tipPose: "T·ªïng s·ªë t∆∞ th·∫ø ch√≠nh (Main Keyframes) c·∫ßn v·∫Ω trong kho·∫£ng th·ªùi gian n√†y.",
        tipFrameRange: "Gi·ªõi h·∫°n th·ªùi gian (t·ª´ khung h√¨nh A ƒë·∫øn B) cho h√†nh ƒë·ªông.",
        tipCalcLogic: "‚Ä¢ Nghi√™m ng·∫∑t: Chia ƒë·ªÅu tuy·ªát ƒë·ªëi.\n‚Ä¢ Ng·∫´u nhi√™n: Th√™m sai l·ªách nh·ªè ƒë·ªÉ t·ª± nhi√™n h∆°n.",
        
        tipPoseCalcMode: "‚Ä¢ Ng·∫´u nhi√™n: H·ªá th·ªëng t·ª± t√≠nh ƒë·ªô d√†i c·∫£nh.\n‚Ä¢ Theo s·ªë gi√¢y: B·∫°n ch·ªß ƒë·ªông ·∫•n ƒë·ªãnh ƒë·ªô d√†i.",
        tipPoseSeconds: "Th·ªùi l∆∞·ª£ng mong mu·ªën c·ªßa c·∫£nh (t√≠nh b·∫±ng gi√¢y).",
        tipFPS_pose: "Khung h√¨nh ti√™u chu·∫©n c·ªßa d·ª± √°n.",
        tipAnimStylePose: "Ki·ªÉu di·ªÖn ho·∫°t (On 1s, 2s, 3s) quy·∫øt ƒë·ªãnh t·ªïng s·ªë l∆∞·ª£ng b·∫£n v·∫Ω.",
        tipFocusTypePose: "Lo·∫°i ƒë·ªëi t∆∞·ª£ng ch√≠nh trong c·∫£nh (Nh√¢n v·∫≠t hay V·∫≠t th·ªÉ).",
        tipFocusActionPose: "H√†nh ƒë·ªông c·ª• th·ªÉ ƒë·ªÉ thu·∫≠t to√°n c√¢n ƒë·ªëi t·ª∑ l·ªá Pose cho ph√π h·ª£p.",
        tipCorePacingPose: "T·ªëc ƒë·ªô t·ªïng th·ªÉ c·ªßa h√†nh ƒë·ªông.",
        tipCurveTypePose: "Quy lu·∫≠t Easing (Nhanh/Ch·∫≠m d·∫ßn) gi·ªØa c√°c Pose.",
        tipSubPose: "H·ªá th·ªëng s·∫Ω t·ª± ƒë·ªông t√≠nh to√°n ch√®n th√™m Pose l√≥t (In-betweens) v√†o kho·∫£ng tr·ªëng gi·ªØa 2 Pose ch√≠nh.",
        tipSubPoseLogic: "Quy t·∫Øc nh·ªìi Pose l√≥t: Ch·ªçn s·ªë l∆∞·ª£ng c·ªë ƒë·ªãnh ho·∫∑c ƒë·ªÉ m√°y r·∫£i ng·∫´u nhi√™n.",
        tipJerkiness: "K·ªπ thu·∫≠t Hold (Gi·ªØ khung h√¨nh) ·ªü ƒëi·ªÉm va ch·∫°m ho·∫∑c cao tr√†o ƒë·ªÉ t·∫°o c·∫£m gi√°c c√≥ l·ª±c (Impact).",
        
        tipTotalFrames: "T·ªïng s·ªë l∆∞·ª£ng Frame m√† ph·∫ßn m·ªÅm th√¥ng b√°o s·∫Ω xu·∫•t ra.",
        tipRenderPerFrame: "Th·ªùi gian th·ª±c t·∫ø ƒë·ªÉ m√°y t√≠nh render xong 1 khung h√¨nh (h√£y render th·ª≠ 1 frame ƒë·ªÉ l·∫•y th√¥ng s·ªë).",

        lblMode: "Lo·∫°i t√≠nh", optF2T: "Frame ‚Üí Time", optT2F: "Time ‚Üí Frame",
        lblFPS_conv: "FPS", lblInput: "S·ªë khung h√¨nh/th·ªùi gian", optSec: "Gi√¢y", optMin: "Ph√∫t", optHour: "Gi·ªù",
        
        lblAnimStyle: "Ki·ªÉu di·ªÖn ho·∫°t", optOn1s: "On 1s (M∆∞·ª£t / H√†nh ƒë·ªông)", optOn2s: "On 2s (Chu·∫©n Anime)", optOn3s: "On 3s (Tƒ©nh / Ch·∫≠m)",
        lblFPS_anime: "FPS g·ªëc", lblCorePacingAnime: "Nh·ªãp t√¢m ƒëi·ªÉm", 
        optCpSuperSlowA: "Super Slow", optCpSlowmoA: "Slow Motion", optCpSlowA: "Ch·∫≠m", optCpNormalA: "B√¨nh th∆∞·ªùng", optCpFastA: "Nhanh", optCpSuperFastA: "C·ª±c nhanh", optCpTimeSplashA: "Time Splash",
        lblCurveTypeAnime: "Lo·∫°i ƒë·ªì th·ªã (Ph√¢n b·ªï)", 
        optCvNoneA: "Kh√¥ng (ƒê·ªÅu)", optCvEaseOutA: "ƒê·ªì th·ªã xu·ªëng (Ch·∫≠m d·∫ßn)", optCvEaseInA: "ƒê·ªì th·ªã l√™n (Nhanh d·∫ßn)", optCvClimaxA: "ƒêi·ªÉm cao tr√†o (Nhanh gi·ªØa)", optCvLowPointA: "ƒêi·ªÉm tr·∫ßm (Ch·∫≠m gi·ªØa)", optCvWaveA: "S√≥ng (Nhanh ch·∫≠m xen k·∫Ω)",
        lblFocus: "T√¢m ƒëi·ªÉm & Tr·∫°ng th√°i", optFocScene: "C·∫£nh", optFocChar: "Nh√¢n v·∫≠t/V·∫≠t th·ªÉ", optStateStatic: "Tƒ©nh", optStateDynamic: "ƒê·ªông",
        lblPose: "S·ªë Pose (Keyframes ch√≠nh)", lblFrameRange: "Frame B·∫Øt ƒë·∫ßu - K·∫øt th√∫c", 
        lblCalcLogic: "Logic t√≠nh to√°n", optLogicStrict: "To√°n h·ªçc nghi√™m ng·∫∑t", optLogicRandom: "X√°c su·∫•t ng·∫´u nhi√™n",
        warnMathModelAnime: "‚ö† Ch·ªâ d√πng ƒë·ªÉ tham kh·∫£o. M√¥ h√¨nh d·ª±a tr√™n n·ªôi suy to√°n h·ªçc v√† ƒë·ªì th·ªã ng·∫´u nhi√™n.",
        
        lblPoseCalcMode: "C√°ch t√≠nh to√°n", optPcalcRandom: "X√°c su·∫•t ng·∫´u nhi√™n", optPcalcSeconds: "Theo s·ªë gi√¢y c·∫£nh",
        lblPoseSeconds: "Nh·∫≠p s·ªë gi√¢y c·∫£nh", lblFPS_pose: "FPS g·ªëc", lblAnimStylePose: "Lo·∫°i di·ªÖn ho·∫°t",
        lblFocusTypePose: "Lo·∫°i t√¢m ƒëi·ªÉm", optFocCharP: "Nh√¢n v·∫≠t", optFocObjP: "V·∫≠t th·ªÉ",
        lblFocusActionPose: "H√†nh ƒë·ªông c·ª• th·ªÉ",
        actTalk: "N√≥i chuy·ªán", actWalk: "ƒêi b·ªô", actRun: "Ch·∫°y", actFight: "ƒê√°nh nhau", actOtherC: "H√†nh ƒë·ªông kh√°c",
        actFly: "Bay", actFall: "R∆°i", actBreak: "V·ª°/G√£y", actBounce: "N·∫£y l√™n/xu·ªëng", actScale: "Ph√≥ng to/Thu nh·ªè", actOtherO: "H√†nh ƒë·ªông kh√°c",
        lblCorePacingPose: "Nh·ªãp t√¢m ƒëi·ªÉm", optCpSuperSlowP: "Super Slow", optCpSlowmoP: "Slow Motion", optCpSlowP: "Ch·∫≠m", optCpNormalP: "B√¨nh th∆∞·ªùng", optCpFastP: "Nhanh", optCpSuperFastP: "C·ª±c nhanh", optCpTimeSplashP: "Time Splash",
        lblCurveTypePose: "Lo·∫°i ƒë·ªì th·ªã", optCvNoneP: "Kh√¥ng", optCvEaseOutP: "ƒê·ªì th·ªã xu·ªëng", optCvEaseInP: "ƒê·ªì th·ªã l√™n", optCvClimaxP: "ƒêi·ªÉm cao tr√†o", optCvLowPointP: "ƒêi·ªÉm tr·∫ßm", optCvWaveP: "S√≥ng",
        lblSubPose: "Th√™m Pose ph·ª• tr·ª£ (In-betweens)", optNo: "Kh√¥ng", optYes: "C√≥",
        lblSubPoseLogic: "Quy t·∫Øc Pose ph·ª• tr·ª£", optSpRandom: "X√°c su·∫•t ng·∫´u nhi√™n",
        lblJerkiness: "ƒê·ªô gi·∫≠t - kh·ª±ng (Stutter/Hold)", optJerkNo: "Kh√¥ng", optJerkFrame: "Theo Frame", optJerkSec: "Theo Gi√¢y",
        warnMathModelPose: "‚ö† Ch·ªâ ƒë·ªÉ tham kh·∫£o, t√≠nh to√°n theo m√¥ h√¨nh to√°n h·ªçc v√† x√°c su·∫•t ng·∫´u nhi√™n.",
        
        lblTotalFrames: "T·ªïng s·ªë frame", lblRenderPerFrame: "Th·ªùi gian render 1 frame (gi√¢y)",
        warningTextRender: "‚ö† Ch·ªâ d√πng ƒë·ªÉ tham kh·∫£o. M·∫≠t ƒë·ªô chi ti·∫øt c·∫£nh th·ª±c t·∫ø s·∫Ω l√†m ƒë·ªïi th·ªùi gian.", lblLanguage: "Ng√¥n ng·ªØ:",
        
        dynFrames: "Khung h√¨nh", dynSec: "gi√¢y", dynKeysSugg: "G·ª£i √Ω Keyframe", dynEstPoses: "Pose ch√≠nh ∆∞·ªõc t√≠nh",
        dynSubPose: "Pose ph·ª•", dynHold: "Gi·∫≠t/Kh·ª±ng (Hold)", dynHoldMsg1: "Khuy√™n d√πng gi·ªØ th√™m", dynHoldMsg2: "t·∫°i ƒëi·ªÉm ch·∫°m/cao tr√†o.",
        dynHintFrames: "G·ª£i √Ω h·ª£p l√Ω: ",
        
        dynClampWarn1: "‚ö†Ô∏è ƒê√£ ƒëi·ªÅu ch·ªânh gi·ªõi h·∫°n: S·ªë pose qu√° l·ªõn so v·ªõi ƒë·ªô d√†i c·∫£nh. ƒê√£ t·ª± ƒë·ªông gi·ªõi h·∫°n l·∫°i c√≤n ",
        dynClampWarn2: " pose ƒë·ªÉ ƒë·∫£m b·∫£o ƒë√∫ng nh·ªãp On ",
        dynClampWarn3: "s.",
        
        lblVisualGraph: "V·∫≠n t·ªëc Easing (L√Ω thuy·∫øt)",
        tipVisualGraph: "Th·ªÉ hi·ªán gia t·ªëc v√† s·ª± thay ƒë·ªïi t·ªëc ƒë·ªô (V·∫≠n t·ªëc). Tr·ª•c gi·ªØa l√† t·ªëc ƒë·ªô ƒë·ªÅu.",
        lblDataGraph: "Bi·ªÉu ƒë·ªì Keyframe (Th·ª±c t·∫ø)",
        tipDataGraph: "V·ªã tr√≠ ch√≠nh x√°c c·ªßa t·ª´ng frame tr√™n tr·ª•c th·ªùi gian sau khi t√≠nh to√°n.",

        phStartFrame: "B·∫Øt ƒë·∫ßu (vd: 1)", phEndFrame: "K·∫øt th√∫c (vd: 100)",
        legendMainKey: "Key ch√≠nh", legendSubKey: "Key ph·ª•"
    },
    en: {
        introText: "Versatile tool for Animation Timing, Frame calculations, and Render estimation.",
        tabConvert: "Time / Frame", tabAnime: "Anime, Toon Frame", tabPose: "Pose Estimator", tabRender: "Render Time",
        
        descConvert: "Tool to seamlessly convert between time duration (Sec/Min/Hour) and total Frames based on FPS.",
        descAnime: "Distribute Keyframes using standard Animation rules (On 1s, 2s, 3s) and calculate scene pacing.",
        descPose: "Automatically estimate main Poses and In-betweens depending on specific action types and duration.",
        descRender: "Estimate the total Render time needed for your project based on a single frame's processing time.",

        tipMode: "Select conversion type:\n‚Ä¢ Frame ‚Üí Time: Convert Frames to Time.\n‚Ä¢ Time ‚Üí Frame: Convert Time to Frames.",
        tipFPS_conv: "FPS (Frames Per Second) determines the speed.\n‚Ä¢ Cinema Standard: 24 fps\n‚Ä¢ TV/Games: 30 or 60 fps.",
        tipInput: "Enter the value to compute (number of frames or sec/min/hour).",
        
        tipAnimStyle: "Defines keys per second:\n‚Ä¢ On 1s: 24 fps (Smooth, Action).\n‚Ä¢ On 2s: 12 fps (Standard Anime).\n‚Ä¢ On 3s: 8 fps (Static, Slow).",
        tipFPS_anime: "Standard framerate of your entire Project (Usually 24).",
        tipCorePacingAnime: "Overall scene speed used to interpolate keyframe distribution.",
        tipCurveTypeAnime: "Acceleration curve (Easing):\n‚Ä¢ Ease Out: Spaced out at the end.\n‚Ä¢ Ease In: Dense at the end.\n‚Ä¢ Climax: Dense in the middle.",
        tipFocus: "Whether the subject is Dynamic (moving) or Static (holding still).",
        tipPose: "Number of main poses (Keyframes) for the action within this timeframe.",
        tipFrameRange: "Time boundary (from frame A to frame B) for calculations.",
        tipCalcLogic: "‚Ä¢ Strict: Absolute even spacing.\n‚Ä¢ Random: Adds natural organic deviation.",
        
        tipPoseCalcMode: "‚Ä¢ Random: Auto scene length.\n‚Ä¢ By Seconds: User-defined fixed time.",
        tipPoseSeconds: "Desired duration of the scene in seconds.",
        tipFPS_pose: "Standard framerate of your entire Project.",
        tipAnimStylePose: "Defines keyframe density which directly affects total drawings.",
        tipFocusTypePose: "Main subject type (Character or Object).",
        tipFocusActionPose: "Specific action for the algorithm to balance pose density.",
        tipCorePacingPose: "Overall speed and intensity of the action.",
        tipCurveTypePose: "Acceleration curve (Ease in, out...) shaping the pose spacing.",
        tipSubPose: "Automatically generate In-between poses between Main Keyframes.",
        tipSubPoseLogic: "In-between padding rule: fixed 1-4 poses or randomly distributed.",
        tipJerkiness: "Hold frames at impact/climax to create a sense of weight and force.",
        
        tipTotalFrames: "Total frames your software requires to render the sequence.",
        tipRenderPerFrame: "Actual time required to render a single test frame.",

        lblMode: "Mode", optF2T: "Frame ‚Üí Time", optT2F: "Time ‚Üí Frame",
        lblFPS_conv: "FPS", lblInput: "Input Value", optSec: "Seconds", optMin: "Minutes", optHour: "Hours",
        
        lblAnimStyle: "Anim Style", optOn1s: "On 1s (Smooth / Action)", optOn2s: "On 2s (Standard Anime)", optOn3s: "On 3s (Static / Slow)",
        lblFPS_anime: "Base FPS", lblCorePacingAnime: "Core Pacing", 
        optCpSuperSlowA: "Super Slow", optCpSlowmoA: "Slow Motion", optCpSlowA: "Slow", optCpNormalA: "Normal", optCpFastA: "Fast", optCpSuperFastA: "Super Fast", optCpTimeSplashA: "Time Splash",
        lblCurveTypeAnime: "Curve Type (Dist.)", 
        optCvNoneA: "None (Linear)", optCvEaseOutA: "Ease Out", optCvEaseInA: "Ease In", optCvClimaxA: "Climax", optCvLowPointA: "Low Point", optCvWaveA: "Wave",
        lblFocus: "Focus & State", optFocScene: "Scene", optFocChar: "Character/Object", optStateStatic: "Static", optStateDynamic: "Dynamic",
        lblPose: "Pose Count (Main Keys)", lblFrameRange: "Start - End Frame", 
        lblCalcLogic: "Logic", optLogicStrict: "Strict Math", optLogicRandom: "Random Probability",
        warnMathModelAnime: "‚ö† Reference only. Based on math interpolation & random probability curves.",
        
        lblPoseCalcMode: "Calc Mode", optPcalcRandom: "Random Probability", optPcalcSeconds: "By Scene Seconds",
        lblPoseSeconds: "Enter Seconds", lblFPS_pose: "Base FPS", lblAnimStylePose: "Anim Style",
        lblFocusTypePose: "Focus Type", optFocCharP: "Character", optFocObjP: "Object",
        lblFocusActionPose: "Specific Action",
        actTalk: "Talking", actWalk: "Walking", actRun: "Running", actFight: "Fighting", actOtherC: "Other Action",
        actFly: "Flying", actFall: "Falling", actBreak: "Breaking", actBounce: "Bouncing", actScale: "Scaling", actOtherO: "Other Action",
        lblCorePacingPose: "Core Pacing", optCpSuperSlowP: "Super Slow", optCpSlowmoP: "Slow Motion", optCpSlowP: "Slow", optCpNormalP: "Normal", optCpFastP: "Fast", optCpSuperFastP: "Super Fast", optCpTimeSplashP: "Time Splash",
        lblCurveTypePose: "Curve Type", optCvNoneP: "None", optCvEaseOutP: "Ease Out", optCvEaseInP: "Ease In", optCvClimaxP: "Climax", optCvLowPointP: "Low Point", optCvWaveP: "Wave",
        lblSubPose: "Add In-betweens", optNo: "No", optYes: "Yes",
        lblSubPoseLogic: "In-between Logic", optSpRandom: "Random Prob.",
        lblJerkiness: "Stutter / Hold", optJerkNo: "No", optJerkFrame: "By Frames", optJerkSec: "By Seconds",
        warnMathModelPose: "‚ö† Reference only, calculated via math models and random probabilities.",
        
        lblTotalFrames: "Total Frames", lblRenderPerFrame: "Time per frame (sec)",
        warningTextRender: "‚ö† Reference only. Real detail density affects time.", lblLanguage: "Language:",
        
        dynFrames: "Frames", dynSec: "sec", dynKeysSugg: "Suggested Keys", dynEstPoses: "Est. Main Poses",
        dynSubPose: "Sub Poses", dynHold: "Hold Effect", dynHoldMsg1: "Suggested holding", dynHoldMsg2: "at impact/climax.",
        dynHintFrames: "Suggested range: ",
        
        dynClampWarn1: "‚ö†Ô∏è Cap adjusted: Scene length too short. Poses automatically capped to ",
        dynClampWarn2: " to preserve On ",
        dynClampWarn3: "s standard.",
        
        lblVisualGraph: "Easing Velocity (Theoretical)",
        tipVisualGraph: "Displays acceleration and changes in speed. Middle line is constant speed.",
        lblDataGraph: "Keyframe Timeline (Actual)",
        tipDataGraph: "Exact placement of each keyframe on the timeline after calculation.",

        phStartFrame: "Start (e.g., 1)", phEndFrame: "End (e.g., 100)",
        legendMainKey: "Main Key", legendSubKey: "Sub Key"
    }
};

function switchTab(tab){
    ["convertMode", "animeMode", "poseMode", "renderMode"].forEach(id => document.getElementById(id).classList.add("hidden"));
    ["tabConvert", "tabAnime", "tabPose", "tabRender"].forEach(id => document.getElementById(id).classList.remove("active"));
    
    document.getElementById(tab + "Mode" + (tab==="convert"?"":"")).classList.remove("hidden");
    if(tab==="convert") document.getElementById("convertMode").classList.remove("hidden");
    document.getElementById("tab" + tab.charAt(0).toUpperCase() + tab.slice(1)).classList.add("active");

    if(tab === "convert") updateConvert();
    if(tab === "anime") updateAnime();
    if(tab === "pose") updatePoseEst();
    if(tab === "render") updateRender();
    updateAllCustomSelects();
}

function setField(id, val) { document.getElementById(id).value = val; }

function updateConvert(){
    let mode = document.getElementById("mode").value;
    let fps = parseFloat(document.getElementById("fps").value);
    let val = parseFloat(document.getElementById("inputValue").value);
    let tUnit = document.getElementById("timeUnit");
    
    let isTime2Frame = (mode === "t2f");
    tUnit.classList.toggle("hidden", !isTime2Frame);
    if (tUnit.parentNode && tUnit.parentNode.classList.contains("custom-select-wrapper")) {
        tUnit.parentNode.classList.toggle("hidden", !isTime2Frame);
    }

    if(isNaN(val) || isNaN(fps) || fps <= 0 || val < 0) { document.getElementById("convertOutput").innerHTML = "‚Äî"; return; }

    if(mode === "f2t"){
        let totalSec = val / fps;
        let mainStr = totalSec.toFixed(3) + " " + i18n[currentLang].dynSec;
        let h = Math.floor(totalSec / 3600), m = Math.floor((totalSec % 3600) / 60), s = parseFloat((totalSec % 60).toFixed(3));
        let subStr = (h > 0 || m > 0) ? `<span class="sub-result">‚âà ${h>0?h+"h ":""}${m}m ${s}s</span>` : "";
        document.getElementById("convertOutput").innerHTML = mainStr + subStr;
    } else {
        let frames = Math.round(val * parseFloat(tUnit.value) * fps);
        document.getElementById("convertOutput").innerHTML = frames + " " + i18n[currentLang].dynFrames;
    }
}

// Fixed getPacingCurve to yield clearer oscillating velocity for 'wave'
function getPacingCurve(x, type) {
    if(type === 'ease_in') return x * x;
    if(type === 'ease_out') return Math.sqrt(x);
    if(type === 'climax') return x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2;
    if(type === 'low_point') return x < 0.5 ? Math.sqrt(2 * x) / 2 : 1 - Math.sqrt(-2 * x + 2) / 2;
    if(type === 'wave') {
        let waves = 3; 
        return x - 0.05 * Math.sin(x * Math.PI * 2 * waves);
    }
    return x;
}

// [FIXED] Draw Pure Velocity Curve (Derivative) with Origin at Middle
function renderStaticCurve(canvasId, curveType) {
    let canvas = document.getElementById(canvasId);
    if(!canvas) return;
    let wrapper = canvas.parentElement;
    if(wrapper) wrapper.classList.remove("hidden");
    
    let ctx = canvas.getContext("2d");
    let w = canvas.width, h = canvas.height;
    let padX = 25, padY = 15;
    let usableW = w - padX * 2;
    let usableH = h - padY * 2;
    let midY = h / 2;
    
    ctx.clearRect(0, 0, w, h);
    
    // Calculate numerical speeds (derivative)
    let speeds = [];
    let dx = 0.01;
    for(let i=0; i<=100; i++) {
        let x = i/100;
        let y1 = getPacingCurve(x, curveType);
        let y2 = getPacingCurve(x + dx, curveType);
        speeds.push((y2 - y1) / dx);
    }
    
    // Baseline (Average Speed = 1)
    ctx.beginPath();
    ctx.moveTo(padX, midY);
    ctx.lineTo(w - padX, midY);
    ctx.strokeStyle = "rgba(255, 204, 102, 0.4)";
    ctx.setLineDash([4, 4]);
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.setLineDash([]);
    
    // Draw Speed Curve
    ctx.beginPath();
    for(let i=0; i<=100; i++) {
        let x = i/100;
        let speed = speeds[i];
        
        // Map: Speed 1 -> midY. Max variance scaled to usableH / 3
        let yPos = midY - (speed - 1) * (usableH / 3); 
        yPos = Math.max(padY, Math.min(h - padY, yPos)); // Clamp
        
        if(i===0) ctx.moveTo(padX + x * usableW, yPos);
        else ctx.lineTo(padX + x * usableW, yPos);
    }
    
    ctx.strokeStyle = "#ffcc66"; 
    ctx.lineWidth = 2.5;
    ctx.stroke();

    // Bottom Axis
    ctx.beginPath();
    ctx.moveTo(padX - 10, h - padY);
    ctx.lineTo(w - padX + 10, h - padY);
    ctx.strokeStyle = "#1e3a5f";
    ctx.lineWidth = 2;
    ctx.stroke();
}

// [FIXED] Graphical Keyframe Timeline with Sub Poses Support
function renderGraph(canvasId, mainKeys, subKeys, minF, maxF) {
    let canvas = document.getElementById(canvasId);
    if(!canvas) return;
    let wrapper = canvas.parentElement;
    
    let allKeys = mainKeys.concat(subKeys || []).sort((a,b)=>a-b);
    if(!allKeys || allKeys.length < 2) { 
        if(wrapper) wrapper.classList.add("hidden"); 
        return; 
    }
    if(wrapper) wrapper.classList.remove("hidden");
    
    let requiredWidth = Math.max(530, allKeys.length * 35);
    canvas.width = requiredWidth;
    
    let ctx = canvas.getContext("2d");
    let w = canvas.width, h = canvas.height;
    let padX = 25, padY = 25;
    let usableW = w - padX * 2;
    let usableH = h - padY * 2;
    
    ctx.clearRect(0, 0, w, h);
    
    let range = maxF - minF;
    if(range <= 0) range = 1;

    // Line connect main frames
    ctx.beginPath();
    mainKeys.forEach((key, index) => {
        let x = padX + ((key - minF) / range) * usableW;
        let y = h - padY - (index / (mainKeys.length - 1)) * usableH;
        if(index === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    });
    ctx.strokeStyle = "#00ccff";
    ctx.lineWidth = 2.5;
    ctx.stroke();

    // Baseline
    ctx.beginPath();
    ctx.moveTo(padX - 10, h - padY);
    ctx.lineTo(w - padX + 10, h - padY);
    ctx.strokeStyle = "#1e3a5f";
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.fillStyle = "#e6f3ff";
    ctx.font = "11px 'Segoe UI', sans-serif";
    ctx.textAlign = "center";
    
    let lastTextX = -50; 
    let stagger = false;

    // Render Sub Keys
    if (subKeys && subKeys.length > 0) {
        subKeys.forEach((key) => {
            let x = padX + ((key - minF) / range) * usableW;
            ctx.beginPath();
            ctx.arc(x, h - padY, 4, 0, Math.PI*2);
            ctx.fillStyle = "#00ccff"; // Xanh lam cho key ph·ª•
            ctx.fill();
            
            ctx.fillStyle = "#9ed8ff";
            ctx.fillText(key, x, h - padY - 8);
        });
    }

    // Render Main Keys
    mainKeys.forEach((key, index) => {
        let x = padX + ((key - minF) / range) * usableW;
        let y = h - padY - (index / (mainKeys.length - 1)) * usableH;
        
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x, h - padY);
        ctx.strokeStyle = "rgba(0, 204, 255, 0.3)";
        ctx.lineWidth = 1;
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(x, y, 3, 0, Math.PI*2);
        ctx.fillStyle = "#fff";
        ctx.fill();

        ctx.beginPath();
        ctx.arc(x, h - padY, 4, 0, Math.PI*2);
        ctx.fillStyle = "#ffcc66"; // V√†ng cho key ch√≠nh
        ctx.fill();

        let textY = h - 5;
        if (x - lastTextX < 18) {
            stagger = !stagger;
            textY = stagger ? h - 5 : h - padY - 8;
        } else {
            stagger = false;
        }
        lastTextX = x;
        
        ctx.fillStyle = "#ffcc66";
        ctx.fillText(key, x, textY);
    });
    
    // Draw Legend
    ctx.font = "12px 'Segoe UI', sans-serif";
    ctx.fillStyle = "#ffcc66"; ctx.fillText("‚óã", w - 120, 15);
    ctx.fillStyle = "#9ed8ff"; ctx.textAlign = "left"; ctx.fillText(i18n[currentLang].legendMainKey, w - 110, 15);
    ctx.fillStyle = "#00ccff"; ctx.fillText("‚óã", w - 55, 15);
    ctx.fillStyle = "#9ed8ff"; ctx.fillText(i18n[currentLang].legendSubKey, w - 45, 15);
}

function toggleAnimePoseInput() {
    document.getElementById("poseRow").classList.toggle("hidden", document.getElementById("focusState").value === "static");
}

function updateAnime() {
    let style = parseInt(document.getElementById("animStyle").value);
    let curve = document.getElementById("curveTypeAnime").value;
    let poses = parseInt(document.getElementById("poseCount").value) || 1;
    let logic = document.getElementById("calcLogic").value;
    let sf = parseInt(document.getElementById("startFrame").value) || 1;
    let ef = parseInt(document.getElementById("endFrame").value) || 100;
    if(sf > ef) { let t = sf; sf = ef; ef = t; }

    let totalF = ef - sf + 1;
    let out = `T·ªïng: <span style="color:white">${totalF}</span> frames<br>`;
    let isClamped = false;
    let maxSlots = Math.floor((totalF - 1) / style) + 1; // Maximum strictly legal slots
    
    if (poses > maxSlots) {
        poses = maxSlots;
        isClamped = true;
    }
    
    let keys = [];
    if (document.getElementById("focusState").value === "dynamic") {
        if(poses === 1) keys.push(sf);
        else {
            for(let i=0; i<poses; i++) {
                let x = i/(poses-1);
                let y = getPacingCurve(x, curve);
                let p = sf + y * (totalF - 1);
                if(logic === "random" && i>0 && i<poses-1) p += (Math.random() * (totalF/poses)*0.3 * (Math.random()>0.5?1:-1));
                
                // [FIXED] Force to strictly adhere to style multiple
                let snap = sf + Math.round((p - sf)/style) * style;
                if(snap > ef) snap -= style; 
                keys.push(snap);
            }
            keys = [...new Set(keys)].sort((a,b)=>a-b);
        }
        
        let t = i18n[currentLang];
        out += `<div class="box-result"><b>${t.dynKeysSugg}:</b><br>${keys.join(" ‚ûî ")}</div>`;
        
        if (isClamped) {
            out += `<div class="warning" style="text-align:left; margin-top: 15px;">${t.dynClampWarn1}<b>${poses}</b>${t.dynClampWarn2}<b>${style}</b>${t.dynClampWarn3}</div>`;
        }
        
        out += `
        <div class="graph-title">
            <span>${t.lblVisualGraph}</span>
            <span class="tooltip" data-tip="${t.tipVisualGraph}">?</span>
        </div>
        <div class="static-graph-wrapper hidden">
            <canvas id="animeStaticGraph" width="530" height="80" class="graph-canvas"></canvas>
        </div>
        
        <div class="graph-title">
            <span>${t.lblDataGraph}</span>
            <span class="tooltip" data-tip="${t.tipDataGraph}">?</span>
        </div>
        <div class="graph-wrapper hidden">
            <canvas id="animeGraph" height="120" class="graph-canvas"></canvas>
        </div>`;
        
        document.getElementById("animeOutput").innerHTML = out;
        renderStaticCurve("animeStaticGraph", curve);
        renderGraph("animeGraph", keys, [], sf, ef);
    } else {
        out += `<div class="box-result">1 Pose gi·ªØ to√†n b·ªô ${totalF} frames.</div>`;
        document.getElementById("animeOutput").innerHTML = out;
    }
}

function updateJerkHint() {
    let jerkType = document.getElementById("jerkToggle").value;
    let hintEl = document.getElementById("jerkHint");
    if(jerkType === "frame") {
        let style = parseInt(document.getElementById("animStylePose").value) || 2;
        let fps = parseFloat(document.getElementById("fpsPose").value) || 24;
        let min = style * 2;
        let max = Math.round((fps / 24) * 6) * style;
        if(max < min) max = min + style;
        hintEl.innerText = `${i18n[currentLang].dynHintFrames}${min} - ${max} frames`;
        hintEl.classList.remove("hidden");
    } else {
        hintEl.classList.add("hidden");
    }
}

function togglePoseSettings() {
    let mode = document.getElementById("poseCalcMode").value;
    document.getElementById("rowPoseSeconds").classList.toggle("hidden", mode !== "seconds");
    
    let sub = document.getElementById("subPoseToggle").value;
    document.getElementById("rowSubPoseLogic").classList.toggle("hidden", sub !== "yes");
    
    if(sub === "yes") {
        document.getElementById("rowJerkiness").classList.add("hidden");
        document.getElementById("jerkToggle").value = "no";
    } else {
        document.getElementById("rowJerkiness").classList.remove("hidden");
    }

    let jerkType = document.getElementById("jerkToggle").value;
    let inputBlock = document.getElementById("jerkInputBlock");
    
    if(jerkType === "no") {
        inputBlock.classList.add("hidden");
    } else {
        inputBlock.classList.remove("hidden");
        
        let jInput = document.getElementById("jerkValue");
        if(jerkType === "sec") { jInput.step = "0.1"; if(jInput.value > 2) jInput.value = 0.2; } 
        else { jInput.step = "1"; if(jInput.value < 1) jInput.value = 4; }
        updateJerkHint();
    }
    if(document.getElementById("jerkToggle").updateCustomUI) document.getElementById("jerkToggle").updateCustomUI();
}

function togglePoseActions() {
    let type = document.getElementById("focusTypePose").value;
    let charWrap = document.getElementById("focusActionChar").previousElementSibling;
    let objWrap = document.getElementById("focusActionObj").previousElementSibling;
    
    if(type === "char") {
        document.getElementById("focusActionObj").classList.add("hidden");
        if(objWrap) objWrap.parentNode.style.display = "none";
        document.getElementById("focusActionChar").classList.remove("hidden");
        if(charWrap) charWrap.parentNode.style.display = "block";
    } else {
        document.getElementById("focusActionChar").classList.add("hidden");
        if(charWrap) charWrap.parentNode.style.display = "none";
        document.getElementById("focusActionObj").classList.remove("hidden");
        if(objWrap) objWrap.parentNode.style.display = "block";
    }
}

function updatePoseEst() {
    let mode = document.getElementById("poseCalcMode").value;
    let sec = parseFloat(document.getElementById("poseSeconds").value) || 1;
    let fps = parseFloat(document.getElementById("fpsPose").value) || 24;
    let style = parseInt(document.getElementById("animStylePose").value) || 2;
    let pacing = document.getElementById("corePacingPose").value;
    let curve = document.getElementById("curveTypePose").value;
    let action = document.getElementById("focusTypePose").value === "char" ? document.getElementById("focusActionChar").value : document.getElementById("focusActionObj").value;
    let useSub = document.getElementById("subPoseToggle").value === "yes";
    let subRule = document.getElementById("subPoseLogic").value;
    let jerkType = document.getElementById("jerkToggle").value;
    let jerkVal = parseFloat(document.getElementById("jerkValue").value) || 0;

    let totalSec = mode === "seconds" ? sec : (Math.random() * 3 + 1.5); 
    let totalFrames = Math.round(totalSec * fps);

    let baseDensity = 1.0;
    if(pacing==="superslow") baseDensity = 0.2;
    else if(pacing==="slowmo") baseDensity = 0.4;
    else if(pacing==="slow") baseDensity = 0.6;
    else if(pacing==="fast") baseDensity = 1.5;
    else if(pacing==="superfast") baseDensity = 2.0;
    else if(pacing==="timesplash") baseDensity = 1.2;

    if(["fight","fly","break","run"].includes(action)) baseDensity *= 1.4;
    if(["talk","scale"].includes(action)) baseDensity *= 0.6;

    let totalDrawings = totalFrames / style;
    let mainPoseCount = Math.max(2, Math.round((totalDrawings * 0.2) * baseDensity));
    if(mode === "random" && Math.random() > 0.5) mainPoseCount += Math.floor(Math.random()*3);

    // [FIXED] Force cap poses so we never produce odd gap clamps
    let isClamped = false;
    let maxSlots = Math.floor((totalFrames - 1) / style) + 1;
    if (mainPoseCount > maxSlots) {
        mainPoseCount = maxSlots;
        isClamped = true;
    }

    let keys = [];
    for(let i=0; i<mainPoseCount; i++) {
        let x = i/(mainPoseCount-1);
        let y = getPacingCurve(x, curve);
        let p = 1 + y * (totalFrames - 1);
        
        let snap = 1 + Math.round((p - 1)/style) * style;
        if (snap > totalFrames) snap -= style; 
        keys.push(snap);
    }
    keys = [...new Set(keys)].sort((a,b)=>a-b);

    let t = i18n[currentLang];
    let out = `‚âà ${totalSec.toFixed(2)} ${t.dynSec} | ${totalFrames} ${t.dynFrames}<br>`;
    out += `<div class="sub-result">${t.dynEstPoses}: ${keys.length} (KFs: ${keys.join(", ")})</div>`;

    let boxHtml = "";
    let subKeysList = [];
    
    // [FIXED] Sub keys array collection
    if(useSub) {
        boxHtml += `<b>${t.dynSubPose}:</b><br>`;
        for(let i=0; i<keys.length-1; i++) {
            let k1 = keys[i], k2 = keys[i+1];
            let subCount = subRule === "random" ? Math.floor(Math.random()*3)+1 : parseInt(subRule);
            let space = (k2 - k1) / (subCount+1);
            if(space >= style) {
                let subs = [];
                for(let j=1; j<=subCount; j++) {
                    let s = k1 + Math.round((space*j)/style)*style;
                    if(s > k1 && s < k2 && !subs.includes(s)) {
                        subs.push(s);
                        subKeysList.push(s);
                    }
                }
                if(subs.length) boxHtml += `‚Ä¢ L√≥t gi·ªØa [${k1}] v√† [${k2}]: ${subs.join(", ")}<br>`;
            }
        }
    }
    
    if(jerkType !== "no" && !useSub && jerkVal > 0) {
        boxHtml += `<hr style="border-color:#1e3a5f; margin:10px 0;"><b>${t.dynHold}:</b><br>`;
        let unitText = jerkType === "sec" ? t.dynSec : t.dynFrames;
        let actualJerkVal = jerkVal;
        let isCappedHold = false;
        
        if (jerkType === "sec") {
            let maxSec = totalSec * 0.4;
            if (actualJerkVal > maxSec) { actualJerkVal = maxSec; isCappedHold = true; }
        } else {
            let maxFrames = Math.floor(totalFrames * 0.4);
            if (maxFrames < 1) maxFrames = 1;
            if (actualJerkVal > maxFrames) { actualJerkVal = maxFrames; isCappedHold = true; }
        }
        
        actualJerkVal = jerkType === "sec" ? actualJerkVal.toFixed(2) : actualJerkVal;
        boxHtml += `${t.dynHoldMsg1} <b>${actualJerkVal}</b> ${unitText} ${t.dynHoldMsg2}`;
        if (isCappedHold) boxHtml += `<br><span style="color:#ffcc66; font-size: 12px;">(ƒê√£ gi·∫£m xu·ªëng t·ªëi ƒëa 40% c·∫£nh ƒë·ªÉ gi·ªØ nh·ªãp)</span>`;
    }

    if(boxHtml !== "") out += `<div class="box-result">${boxHtml}</div>`;
    
    if(isClamped) {
        out += `<div class="warning" style="text-align:left; margin-top: 15px;">${t.dynClampWarn1}<b>${mainPoseCount}</b>${t.dynClampWarn2}<b>${style}</b>${t.dynClampWarn3}</div>`;
    }

    out += `
    <div class="graph-title">
        <span>${t.lblVisualGraph}</span>
        <span class="tooltip" data-tip="${t.tipVisualGraph}">?</span>
    </div>
    <div class="static-graph-wrapper hidden">
        <canvas id="poseStaticGraph" width="530" height="80" class="graph-canvas"></canvas>
    </div>
    
    <div class="graph-title">
        <span>${t.lblDataGraph}</span>
        <span class="tooltip" data-tip="${t.tipDataGraph}">?</span>
    </div>
    <div class="graph-wrapper hidden">
        <canvas id="poseGraph" height="120" class="graph-canvas"></canvas>
    </div>`;
    
    document.getElementById("poseOutput").innerHTML = out;
    renderStaticCurve("poseStaticGraph", curve);
    renderGraph("poseGraph", keys, subKeysList, 1, totalFrames);
}

function updateRender(){
    let frames = parseFloat(document.getElementById("totalFrames").value);
    let pFrame = parseFloat(document.getElementById("renderPerFrame").value);
    if(isNaN(frames) || isNaN(pFrame) || frames < 0 || pFrame < 0) { document.getElementById("renderOutput").innerText = "‚Äî"; return; }
    let tot = frames * pFrame;
    let d = Math.floor(tot / 86400), h = Math.floor((tot % 86400) / 3600), m = Math.floor((tot % 3600) / 60), s = Math.floor(tot % 60);
    let str = (d > 0 ? d + (currentLang==="vi"?" ng√†y ":"d ") : "") + `${h}h ${m}m ${s}s`;
    document.getElementById("renderOutput").innerText = str;
}

function changeLang(lang) {
    currentLang = lang; let t = i18n[lang];
    
    for (let id in t) {
        let el = document.getElementById(id);
        if (el) {
            if (el.classList.contains("tooltip")) {
                el.dataset.tip = t[id];
            } else if(el.hasAttribute("data-i18n-ph")) {
                let pKey = el.getAttribute("data-i18n-ph");
                if(t[pKey]) el.placeholder = t[pKey];
            } else {
                el.innerText = t[id];
            }
        }
    }
    
    // Check specific placeholders manually in case query failed
    let sF = document.getElementById("startFrame");
    if(sF) sF.placeholder = t.phStartFrame;
    let eF = document.getElementById("endFrame");
    if(eF) eF.placeholder = t.phEndFrame;

    updateConvert(); updateAnime(); updatePoseEst(); updateRender(); updateAllCustomSelects(); updateJerkHint();
}

function initCustomSelects() {
    document.querySelectorAll("select").forEach(sel => {
        if(sel.nextElementSibling && sel.nextElementSibling.classList.contains("custom-select-options")) return;
        const wrap = document.createElement("div"); wrap.className = "custom-select-wrapper";
        sel.parentNode.insertBefore(wrap, sel); wrap.appendChild(sel);
        
        const trig = document.createElement("div"); trig.className = "custom-select-trigger";
        const opts = document.createElement("div"); opts.className = "custom-select-options";
        wrap.appendChild(trig); wrap.appendChild(opts);
        
        function updateUI() { if(sel.selectedIndex >= 0) trig.innerHTML = `<span>${sel.options[sel.selectedIndex].text}</span><div class="arrow"></div>`; }
        function buildOpts() {
            opts.innerHTML = "";
            Array.from(sel.options).forEach((o, i) => {
                const od = document.createElement("div"); od.className = "custom-select-option";
                if(i === sel.selectedIndex) od.classList.add("selected"); od.innerText = o.text;
                od.addEventListener("click", (e) => {
                    e.stopPropagation(); sel.selectedIndex = i; sel.dispatchEvent(new Event("change"));
                    updateUI(); opts.classList.remove("show"); trig.classList.remove("active");
                });
                opts.appendChild(od);
            });
        }
        trig.addEventListener("click", (e) => {
            e.stopPropagation(); const isS = opts.classList.contains("show");
            document.querySelectorAll(".custom-select-options").forEach(el => el.classList.remove("show"));
            document.querySelectorAll(".custom-select-trigger").forEach(el => el.classList.remove("active"));
            if(!isS) { buildOpts(); opts.classList.add("show"); trig.classList.add("active"); }
        });
        updateUI(); sel.style.display = "none"; sel.updateCustomUI = updateUI;
    });
    document.addEventListener("click", () => {
        document.querySelectorAll(".custom-select-options").forEach(el => el.classList.remove("show"));
        document.querySelectorAll(".custom-select-trigger").forEach(el => el.classList.remove("active"));
    });
}
function updateAllCustomSelects() { document.querySelectorAll("select").forEach(s => { if(s.updateCustomUI) s.updateCustomUI(); }); }

window.addEventListener("DOMContentLoaded", () => { 
    initCustomSelects(); 
    changeLang('vi'); 
    togglePoseActions();
    togglePoseSettings();
});
</script>
</body>
</html>

